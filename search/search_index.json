{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#network-automations-fabric","title":"Network Automations Fabric","text":"<p>Hi , thank you for getting here.</p>"},{"location":"#why-the-story","title":"Why (The Story)","text":"<p>In a world devoid of network automations, the streets were silent  and grey. Without network automations, network engineers' lives  became a grueling cycle of manual configurations and endless  troubleshooting. They spent hours accessing each and every device,  manually configuring and patching systems. Nights were sleepless,  filled with frantic calls to resolve outages that could no longer  be preemptively detected or resolved. Collaboration was slow,  relying on face-to-face meetings and paper documentation.  Overwhelmed and exhausted, their innovative spirit was stifled by  the sheer volume of repetitive tasks...</p> <p>Let us introduce you to the world of Network Automations Fabric.</p>"},{"location":"#what-the-idea","title":"What (The Idea)","text":"<p>Most of the software to manage networks falls into one of the two categories: </p> <ul> <li>heavyweight platforms running on dedicated infrastructure</li> <li>lightweight scripts or tools developed and run locally</li> </ul> <p>NorFab goal is to be both - software you can run equally well from your laptop or on a server, centralized or fully distributed,  lightweight and feature reach. Capable of doing any use cases  without the need to throw gazillions of dollars and man hours at  it. Always ready to serve the purpose of unlocking engineers  superpowers managing modern network and making their life better.</p>"},{"location":"#how-the-features","title":"How (The Features)","text":"<ul> <li>Run Anywhere - locally on Windows, MAC or Linux, in a container, on a VM, in the cloud, centralized or distributed</li> <li>Extend Anything - extendability is in the core of NorFab</li> <li>Integrate with Everything - Python API, REST API, CLI northbound interfaces</li> <li>Manage Anything - develop your own services or use built-in to manage your network infrastructure</li> <li>Model and data driven - Pydantic models for API, validation and documentation</li> <li>Automate Anything - we mean it, sky is the limit on what you can do with NorFab automating your networks</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Key actors of the system include</p> <ul> <li>Workers - form Services</li> <li>Clients - consume Services</li> <li>Broker - middleman between Clients and Services</li> </ul> <p>Clients communicate with broker to run the jobs, broker distributes  jobs across workers comprising the service, workers run jobs producing  results later on retrieved by clients. In other words Services  hosted by Workers and expose functionality consumed by Clients  via Broker.</p>"},{"location":"NFP/","title":"NORFAB Protocol","text":"<p>Status: experimental Editor: d.mulyalin@gmail.com Contributors: </p> <p>The NORFAB Protocol (NFP) defines a reliable service-oriented request-reply dialog between a set of client applications, a broker and a set of worker applications representing service managing a set of resources. </p> <p>NFP covers presence, heartbeating, and service-resource-oriented request-reply processing. NFP originated from the MDP pattern defined in Chapter 4 of the ZeroMQ Guide and combined with TSP pattern (developed in same chapter) approach for persistent messaging across a network of arbitrarily connected clients and workers as a design for disk-based reliable messaging. NORFAB allows clients and workers to work without being connected to the network at the same time, and defines handshaking for safe storage of requests, and retrieval of replies.</p>"},{"location":"NFP/#license","title":"License","text":"<p>Copyright (c) 2024 Denis Mulyalin.</p> <p>This Specification is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p> <p>This Specification is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p> <p>You should have received a copy of the GNU General Public License along with this program; if not, see http://www.gnu.org/licenses.</p>"},{"location":"NFP/#change-process","title":"Change Process","text":"<p>This Specification is a free and open standard (see \u201cDefinition of a Free and Open Standard\") and is governed by the Digital Standards Organization\u2019s Consensus-Oriented Specification System (COSS) (see \u201cConsensus Oriented Specification System\").</p>"},{"location":"NFP/#language","title":"Language","text":"<p>The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 (see \u201cKey words for use in RFCs to Indicate Requirement Levels\").</p>"},{"location":"NFP/#goals","title":"Goals","text":"<p>The NORFAB Protocol (NFP) defines a reliable service-resource-oriented request-reply dialog between a set of client applications, a broker and a set of worker applications. NFP covers presence, heartbeating, and service-oriented request-reply processing. </p> <p>NFP uses name-based service resolution, named based resource targeting and structured protocol commands.</p> <p>The goals of NFP are to:</p> <ul> <li>Allow requests to be routed to workers on the basis of abstract service names.</li> <li>Allow broker and workers to detect disconnection of one another, through the use of heartbeating.</li> <li>ALlow task distribution by clients targeting <code>all</code> (broadcast), <code>any</code> (anycast) or <code>unicast</code> certain workers by names within given service.</li> <li>Allow the broker to recover from dead or disconnected workers by re-sending requests to other workers.</li> <li>Allow workers to manage <code>resource</code> entities, where entities can be dynamically distributed across all workers within the service.</li> <li>Allow workers to have access to inventory data hosted by broker</li> </ul>"},{"location":"NFP/#architecture","title":"Architecture","text":""},{"location":"NFP/#overall-topology","title":"Overall Topology","text":"<p>NFP connects a set of client applications, a single broker device and a pool of workers applications. Clients connect to the broker, as do workers. Clients and workers do not see each other, and both can come and go arbitrarily. The broker MAY open two sockets (ports), one front-end for clients, and one back-end for workers. However NFP is also designed to work over a single broker socket.</p> <p>We define \u2018client\u2019 applications as those issuing requests, and \u2018worker\u2019 applications as those processing them. NFP makes these assumptions:</p> <ul> <li>Workers are idempotent, i.e. it is safe to execute the same request more than once.</li> <li>Workers will handle at most one request a time, and will issue exactly one reply for each successful request.</li> <li>The NORFAB broker mediates requests one a per service basis. The broker SHOULD serve clients on a fair basis and SHOULD deliver requests to workers on the basis of targeting specified by client - <code>any</code> worker, <code>all</code> workers or <code>unicast</code> worker identified by name.</li> </ul> <p>NFP consists of four sub-protocols:</p> <ul> <li>NFP/Client, which covers how the NFP broker communicates with client applications.</li> <li>NFP/Worker, which covers how the NFP broker communicates with workers applications.</li> <li>NFP/Worker-PUB, which covers how broker subscribes to events published by workers.</li> <li>NFP/Broker-PUB, which covers how broker publishes collected worker events to clients.</li> </ul> <p>The broker SHOULD be an intermediary (a device) application that mediates Client-Workers communication. The broker SHOULD integrate Management Interface (MMI) service directly into it together with simple disk based Inventory service for workers.</p>"},{"location":"NFP/#router-addressing","title":"ROUTER Addressing","text":"<p>The broker MUST use a ROUTER socket to accept requests from clients, and connections from workers. The broker MAY use a separate socket for each sub-protocol, or MAY use a single socket for both sub-protocols.</p> <p>From the \u00d8MQ Reference Manual:</p> <p>When receiving messages a ROUTER socket shall prepend a message part containing the identity of the originating peer to the message before passing it to the application. When sending messages a ROUTER socket shall remove the first part of the message and use it to determine the identity of the peer the message shall be routed to.</p> <p>This extra frame is not shown in the sub-protocol commands explained below.</p>"},{"location":"NFP/#nfp-messages","title":"NFP messages","text":""},{"location":"NFP/#open","title":"OPEN","text":"<p>A OPEN command consists of 4 frames, formatted on the wire as follows:</p> <pre><code>OPEN command\n---------------------------------------------------------------\nFrame 0: Empty frame\nFrame 1: \u201cNFPC01\u201d or \u201cNFPW01\u201d or \u201cNFPB01\u201d (six bytes, representing NFP/Client or NFP/Worker or NFP/Broker v0.1)\nFrame 2: 0x00 (one byte, representing OPEN)\nFrame 3: Open body (opaque binary)\n</code></pre> <p>Worker and client use OPEN message to introduce itself to broker to negotiate connection parameters. Broker sends OPEN message back to client or worker to confirm the connection.</p>"},{"location":"NFP/#ready","title":"READY","text":"<p>A READY command consists of a multipart message of 4 frames, formatted on the wire as follows:</p> <pre><code>READY command\n---------------------------------------------------------------\nFrame 0: Empty frame\nFrame 1: \u201cNFPW01\u201d (six bytes, representing NFP/Worker v0.1)\nFrame 2: 0x01 (one byte, representing READY)\nFrame 3: Service name (printable string)\n</code></pre> <p>Worker sends READY command to broker, broker accepts ready request and registers worker with a service.</p>"},{"location":"NFP/#keepalive","title":"KEEPALIVE","text":"<p>A KEEPALIVE command consists of 4 frames, formatted on the wire as follows:</p> <pre><code>KEEPALIVE command\n---------------------------------------------------------------\nFrame 0: Empty frame\nFrame 1: \u201cNFPB01\u201d or \u201cNFPW01\u201d (six bytes, representing NFP/Broker or NFP/Worker v0.1)\nFrame 2: 0x02 (one byte, representing KEEPALIVE)\nFrame 3: Service name (printable string)\n</code></pre> <p>Broker sends KEEPALIVE messages to workers to indicate broker is still alive.</p> <p>Workers send KEEPALIVE messages to broker to indicate worker is still alive.</p>"},{"location":"NFP/#disconnect","title":"DISCONNECT","text":"<p>A DISCONNECT command consists of 3 frames, formatted on the wire as follows:</p> <pre><code>DISCONNECT command\n---------------------------------------------------------------\nFrame 0: Empty frame\nFrame 1: \u201cNFPB01\u201d or \u201cNFPW01\u201d (six bytes, representing NFP/Broker or NFP/Worker v0.1)\nFrame 2: 0x03 (one byte, representing DISCONNECT)\nFrame 3: Service name (printable string)\nFrame 4: Disconnect body (opaque binary)\n</code></pre> <p>Broker sends DISCONNECT command to workers to signal the request to disconnect. </p> <p>Workers also can send DISCONNECT command to broker to signal the request to disconnect. </p>"},{"location":"NFP/#post","title":"POST","text":"<p>A POST command consists of 7 or more frames, formatted on the wire as follows:</p> <pre><code>POST command\n---------------------------------------------------------------\nFrame 0: Empty (zero bytes, invisible to REQ application)\nFrame 1: \u201cNFPC01\u201d or \"NFPB01\" (six bytes, representing NFP/Client or NFP/Broker v0.1)\nFrame 2: 0x04 (one byte, representing POST)\nFrame 3: Service name (printable string)\nFrame 4: Target (printable string) workers, `all` (default), `any` or comma separated `worker names`\nFrame 5: Job UUID (printable string)\nFrames 6: POST body (opaque binary)\n</code></pre> <p>Client sends POST message to broker to distribute job requests among workers. </p> <p>Broker relays POST message to individual workers to publish job request.</p>"},{"location":"NFP/#response","title":"RESPONSE","text":"<p>A RESPONSE command consists of 7 or more frames, formatted on the wire as follows:</p> <pre><code>RESPONSE command\n---------------------------------------------------------------\nFrame 0: Empty (zero bytes, invisible to REQ application)\nFrame 1: \u201cNFPB01\u201d or \u201cNFPW01\u201d (six bytes, representing NFP/Broker or NFP/Worker v0.1)\nFrame 2: 0x05 (one byte, representing RESPONSE)\nFrame 3: Service name (printable string)\nFrame 4: Job UUID (printable string)\nFrame 5: Status code, (explained below)\nFrames 6: Response body (opaque binary)\n</code></pre> <p>Worker sends RESPONSE message to broker with requests status or job results. </p> <p>Broker relays RESPONSE message to client.</p>"},{"location":"NFP/#get","title":"GET","text":"<p>A GET command consists of 7 or more frames, formatted on the wire as follows:</p> <pre><code>GET command\n---------------------------------------------------------------\nFrame 0: Empty (zero bytes, invisible to REQ application)\nFrame 1: \u201cNFPC01\u201d or \"NFPB01\" (six bytes, representing NFP/Client or NFP/Broker v0.1)\nFrame 2: 0x06 (one byte, representing GET)\nFrame 3: Service name (printable string)\nFrame 4: Target (printable string) workers, `all` (default), `any` or comma separated `worker names`\nFrame 5: Job UUID (printable string)\nFrames 6: GET request body (opaque binary)\n</code></pre> <p>Client sends GET message to broker to retrieve job results. </p> <p>Broker relays GET message to individual workers to request job request.</p>"},{"location":"NFP/#delete","title":"DELETE","text":"<p>A DELETE command consists of 7 or more frames, formatted on the wire as follows:</p> <pre><code>DELETE command\n---------------------------------------------------------------\nFrame 0: Empty (zero bytes, invisible to REQ application)\nFrame 1: \u201cNFPC01\u201d or \"NFPB01\" (six bytes, representing NFP/Client or NFP/Broker v0.1)\nFrame 2: 0x07 (one byte, representing POST)\nFrame 3: Service name (printable string)\nFrame 4: Target (printable string) workers, `all` (default), `any` or comma separated `worker names`\nFrame 5: Job UUID (printable string)\nFrames 6: DELETE body (opaque binary)\n</code></pre> <p>Client sends DELETE message to broker to distribute job delete requests to workers. </p> <p>Broker relays DELETE message to individual workers to cancel the job.</p>"},{"location":"NFP/#status-frames","title":"Status Frames","text":"<p>Every RESPONSE message contains a status frame followed by zero or more content frames. The status frame contains a string formatted as three digits, optionally followed by a space and descriptive text. A client MUST NOT treat the text as significant in any way. Implementations MAY NOT use status codes that are not defined here:</p> <p>200 - OK. The NORFAB worker executed the request successfully.  202 - ACCEPTED. The NORFAB Broker accepted POST request to dispatch the job. 300 - PENDING. The client SHOULD retry the request at a later time. 400 - UNKNOWN. The client is using an invalid or unknown UUID and SHOULD NOT retry. 408 - REQUEST TIMEOUT. Client did not receive response from broker or worker. 417 - EXPECT FAILED. Client did not receive what it was expecting to receive. 500 - ERROR. The server cannot complete the request due to some internal error. The client SHOULD retry at some later time.</p>"},{"location":"NFP/#nfpclient","title":"NFP/Client","text":"<p>NFP/Client is a strictly synchronous dialog initiated by the client (where \u2018C\u2019 represents the client, and \u2018B\u2019 represents the broker):</p> <pre><code>C: OPEN\nB: OPEN\n\nRepeat:\n\n    C: POST\n    B: RESPONSE\n    ...\n\n    C: GET\n    B: RESPONSE\n    ...\n</code></pre> <p>Clients SHOULD use a REQ socket when implementing a synchronous request-reply pattern. The REQ socket will silently create frame 0 for outgoing requests, and remove it for replies before passing them to the calling application. </p> <p>Clients MAY use any suitable strategy for recovering from a non-responsive broker. One recommended strategy is:</p> <ul> <li>To use polling instead of blocking receives on the request socket.</li> <li>If there is no reply within some timeout, to close the request socket and open a new socket, and resend the request on that new socket.</li> <li>If there is no reply after several retries, to signal the transaction as failed.</li> <li>The service name is a 0MQ string that matches the service name specified by a worker in its READY command (see NFP/Worker below). The broker SHOULD queue client requests for which service no workers has been registered and SHOULD expire these requests after a reasonable and configurable time if no service's workers has been registered.</li> </ul>"},{"location":"NFP/#nfpbroker","title":"NFP/Broker","text":"<p>NFP/Broker is a mediator that receives messages from clients and dispatches them out to workers. In return messages from workers routed to clients.</p>"},{"location":"NFP/#nfpworker","title":"NFP/Worker","text":"<p>NFP/Worker is a mix of a synchronous request-reply dialog, initiated by the service worker, and an asynchronous heartbeat dialog that operates independently in both directions. This is the synchronous dialog (where \u2018W\u2019 represents the service worker, and \u2018B\u2019 represents the broker):</p> <pre><code>W: OPEN\nB: OPEN\nW: READY\n\nRepeat:\n\n    B: POST\n    W: RESPONSE\n    ...\n\n    B: GET\n    W: RESPONSE\n    ... \n</code></pre> <p>The asynchronous heartbeat dialog operates on the same sockets and works thus:</p> <pre><code>Repeat:                 Repeat:\n\n    W: HEARTBEAT            B: HEARTBEAT\n    ...                     ...\n\nW: DISCONNECT           B: DISCONNECT\n</code></pre> <p>NFP/Worker commands all start with an empty frame to allow consistent processing of client and worker frames in a broker, over a single socket. The empty frame has no other significance.</p>"},{"location":"NFP/#nfpworker-pub","title":"NFP/Worker-PUB","text":"<p>TBD </p>"},{"location":"NFP/#nfpbroker-pub","title":"NFP/Broker-PUB","text":"<p>TBD</p>"},{"location":"NFP/#job-persistence","title":"Job Persistence","text":"<p>Workers SHOULD persistently store job requests and job execution results for a configurable amount of time allowing clients (client submitted job request or any other client) to request job execution results on demand.</p> <p>Clients SHOULD persistently store job requests and MAY store job execution results locally for a configurable amount of time.</p>"},{"location":"NFP/#opening-and-closing-a-connection","title":"Opening and Closing a Connection","text":"<p>The worker is responsible for opening and closing a logical connection. One worker MUST connect to exactly one broker using a single \u00d8MQ DEALER (XREQ) socket.</p> <p>Since \u00d8MQ automatically reconnects peers after a failure, every NFP command includes the protocol header to allow proper validation of all messages that a peer receives.</p> <p>The worker opens the connection to the broker by creating a new socket, connecting it, and then sending a READY command to register to a service. One worker handles precisely one service, and many workers MAY handle the same service. The worker MUST NOT send a further READY.</p> <p>There is no response to a READY. The worker SHOULD assume the registration succeeded until or unless it receives a DISCONNECT, or it detects a broker failure through heartbeating.</p> <p>The worker MAY send DISCONNECT at any time, including before READY. When the broker receives DISCONNECT from a worker it MUST send no further commands to that worker.</p> <p>The broker MAY send DISCONNECT at any time, by definition after it has received at least one command from the worker.</p> <p>The broker MUST respond to any valid but unexpected command by sending DISCONNECT and then no further commands to that worker. The broker SHOULD respond to invalid messages by dropping them and treating that peer as invalid.</p> <p>When the worker receives DISCONNECT it must send no further commands to the broker; it MUST close its socket, and reconnect to the broker on a new socket. This mechanism allows workers to re-register after a broker failure and recovery.</p>"},{"location":"NFP/#post-and-response-processing","title":"POST and RESPONSE Processing","text":"<p>The POST and the RESPONSE commands MUST contain precisely one client address frame. This frame MUST be followed by an empty (zero sized) frame.</p> <p>The address of each directly connected client is prepended by the ROUTER socket to all request messages coming from clients. That ROUTER socket also expects a client address to be prepended to each reply message sent to a client.</p>"},{"location":"NFP/#keepaliving","title":"Keepaliving","text":"<p>KEEPALIVE commands are valid at any time, after a READY command.</p> <p>Any received command except DISCONNECT acts as a keepalive. Peers SHOULD NOT send KEEPALIVE commands while also sending other commands.</p> <p>Both broker and worker MUST send heartbeats at regular and agreed-upon intervals. A peer MUST consider the other peer \u201cdisconnected\u201d if no keepalive arrives within some multiple of that interval (usually 3-5).</p> <p>If the worker detects that the broker has disconnected, it SHOULD restart a new conversation.</p> <p>If the broker detects that the worked has disconnected, it SHOULD stop sending messages of any type to that worker.</p>"},{"location":"NFP/#broker-management-interface-bmmi","title":"Broker Management Interface (BMMI)","text":"<p>Broker SHOULD implement Management interface as a service endpoint for clients to interact with.</p> <p>Broker should use <code>mmi.service.broker</code> service endpoint to listen to client's requests. </p> <p>These MMI functions SHOULD be implemented:</p> <ul> <li><code>show_broker</code> - to return broker status and statistics</li> <li><code>show_workers</code> - to return worker status and statistics </li> <li><code>show_clients</code> - to return clients statistics</li> <li><code>show_services</code> - to return services status and statistics </li> <li><code>restart</code> - restart broker</li> <li><code>shutdown</code> - shutdown broker completely</li> <li><code>disconnect</code> - to disconnect all workers</li> </ul>"},{"location":"NFP/#worker-management-interface-wmmi","title":"Worker Management Interface (WMMI)","text":"<p>Worker SHOULD implement Management interface as a service endpoint for clients to interact with.</p> <p>Worker should use <code>mmi.service.worker</code> service endpoint to listen to client's requests. </p> <p>These MMI functions SHOULD be implemented:</p> <ul> <li><code>show_broker</code> - to return broker status and statistics</li> <li><code>show_workers</code> - to return worker status and statistics </li> <li><code>show_clients</code> - to return clients statistics</li> <li><code>restart</code> - restart worker</li> <li><code>shutdown</code> - shutdown worker completely</li> <li><code>disconnect</code> - to disconnect worker from broker and re-establish connection</li> </ul>"},{"location":"NFP/#broker-simple-inventory-datastore-sid","title":"Broker Simple Inventory Datastore (SID)","text":"<p>Broker should implement Inventory Datastore to store and serve configuration to workers as well as arbitrary workers inventory data.</p> <p>Broker should use <code>sid.service.broker</code> service endpoint to listen to worker's requests. </p> <p>Workers willing to make use of broker's inventory datastore should implement <code>NFP/Client</code> protocol defined above to request inventory data.</p> <p>These SID functions SHOULD be implemented:</p> <ul> <li><code>get_inventory</code> - to return inventory content for given worker</li> </ul>"},{"location":"NFP/#sid-implementation","title":"SID Implementation","text":"<p>TBD</p>"},{"location":"NFP/#broker-file-sharing-service-fss","title":"Broker File Sharing Service (FSS)","text":"<p>Broker implements service to serve files to clients and workers from local file system using <code>nf://&lt;filepath&gt;</code> URL for supported arguments.</p> <p>Broker should use <code>fss.service.broker</code> service endpoint to listen to worker's requests. </p>"},{"location":"NFP/#fss-implementation","title":"FSS Implementation","text":"<p>TBD</p>"},{"location":"NFP/#reliability","title":"Reliability","text":"<p>The NORFAB pattern is designed to extend the basic \u00d8MQ request-reply pattern with the ability to detect and recover from a specific set of failures:</p> <ul> <li>Worker applications which crash, run too slowly, or freeze.</li> <li>Worker applications that are disconnected from the network (temporarily or permanently).</li> <li>Client applications that are temporarily disconnected from the network.</li> <li>A queue broker that crashes and is restarted.</li> <li>A queue broker that suffers a permanent failure.</li> <li>Requests or replies that are lost due to any of these failures.</li> <li>The general approach is to retry and reconnect, using heartbeating when needed. </li> </ul>"},{"location":"NFP/#scalability-and-performance","title":"Scalability and Performance","text":"<p>NORFAB is designed to be scalable to large numbers (thousands) of workers and clients allowing to manage 10s of thousands resource entities, limited only by system resources on the broker. Partitioning of workers by service allows for multiple applications to share the same broker infrastructure. Workers manage a set of resources defined by system administrator. Same resource can be managed by single or multiple workers, system impose no restrictions on how resource entities distributed across workers.</p> <p>Throughput performance for a single client application will be limited to tens of thousands, not millions, of request-reply transactions per second due to round-trip costs and the extra latency of a broker-based approach. The larger the request and reply messages, the more efficient NORFAB will become. </p> <p>System requirements for the broker are moderate: no more than one outstanding request per client will be queued, and message contents can be switched between clients and workers without copying or processing. A single broker thread can therefore switch several million messages per second.</p>"},{"location":"NFP/#security","title":"Security","text":""},{"location":"NFP/#worker-authentication","title":"Worker Authentication","text":"<p>TBD</p>"},{"location":"NFP/#worker-authorization","title":"Worker Authorization","text":"<p>TBD</p>"},{"location":"NFP/#client-authentication","title":"Client Authentication","text":"<p>TBD</p>"},{"location":"NFP/#client-authorization-role-based-access-control-rbac","title":"Client Authorization - Role Based Access Control (RBAC)","text":"<p>TBD</p>"},{"location":"NFP/#client-encryption","title":"Client Encryption","text":"<p>TBD</p>"},{"location":"NFP/#worker-encryption","title":"Worker Encryption","text":"<p>TBD</p>"},{"location":"NFP/#accounting","title":"Accounting","text":"<p>TBD</p>"},{"location":"NFP/#known-weaknesses","title":"Known Weaknesses","text":"<ul> <li>The heartbeat rate must be set to similar values in broker and worker, or false disconnections will occur. </li> <li>The use of multiple frames for command formatting has a performance impact.</li> </ul>"},{"location":"netbox_worker_api_reference/","title":"Netbox Worker","text":""},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker","title":"<code>NetboxWorker(broker, service, worker_name, exit_event=None, log_level='WARNING')</code>","text":"<p>               Bases: <code>NFPWorker</code></p> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def __init__(\n    self, broker, service, worker_name, exit_event=None, log_level=\"WARNING\"\n):\n    super().__init__(broker, service, worker_name, exit_event, log_level)\n\n    # get inventory from broker\n    self.inventory = self.load_inventory()\n    if not self.inventory:\n        log.critical(\n            f\"Broker {self.broker} returned no inventory for {self.name}, killing myself...\"\n        )\n        self.destroy()\n\n    assert self.inventory.get(\n        \"instances\"\n    ), f\"{self.name} - inventory has no Netbox instances\"\n\n    # find default instance\n    for name, params in self.inventory[\"instances\"].items():\n        if params.get(\"default\") is True:\n            self.default_instance = name\n            break\n    else:\n        self.default_instance = name\n\n    # check Netbox compatibility\n    self._verify_compatibility()\n\n    log.info(f\"{self.name} - Started\")\n</code></pre>"},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker.graphql","title":"<code>graphql(instance=None, dry_run=False, obj=None, filters=None, fields=None, queries=None, query_string=None)</code>","text":"<p>Function to send query to Netbox GraphQL API and return results.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>Netbox instance name</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>only return query content, do not run it</p> <code>False</code> <code>obj</code> <code>dict</code> <p>object to return data for e.g. device, interface, ip_address</p> <code>None</code> <code>filters</code> <code>dict</code> <p>dictionary of key-value pairs to filter by</p> <code>None</code> <code>fields</code> <code>list</code> <p>list of data fields to return</p> <code>None</code> <code>queries</code> <code>dict</code> <p>dictionary keyed by GraphQL aliases with values of obj, filters, fields dictionary</p> <code>None</code> <code>query_string</code> <code>str</code> <p>string with GraphQL query</p> <code>None</code> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def graphql(\n    self,\n    instance: str = None,\n    dry_run: bool = False,\n    obj: dict = None,\n    filters: dict = None,\n    fields: list = None,\n    queries: dict = None,\n    query_string: str = None,\n):\n    \"\"\"\n    Function to send query to Netbox GraphQL API and return results.\n\n    :param instance: Netbox instance name\n    :param dry_run: only return query content, do not run it\n    :param obj: object to return data for e.g. device, interface, ip_address\n    :param filters: dictionary of key-value pairs to filter by\n    :param fields: list of data fields to return\n    :param queries: dictionary keyed by GraphQL aliases with values of obj, filters, fields dictionary\n    :param query_string: string with GraphQL query\n    \"\"\"\n    nb_params = self._get_instance_params(instance)\n\n    # form graphql query(ies) payload\n    if queries:\n        queries_list = []\n        for alias, query_data in queries.items():\n            query_data[\"alias\"] = alias\n            queries_list.append(_form_query(**query_data))\n        queries_strings = \"    \".join(queries_list)\n        query = f\"query {{{queries_strings}}}\"\n    elif obj and filters and fields:\n        query = _form_query(obj, filters, fields)\n        query = f\"query {{{query}}}\"\n    elif query_string:\n        query = query_string\n    else:\n        raise RuntimeError(\n            f\"{self.name} - graphql method expects quieries argument or obj, filters, \"\n            f\"fields arguments or query_string argument provided\"\n        )\n    payload = json.dumps({\"query\": query})\n\n    # form and return dry run response\n    if dry_run:\n        return {\n            \"url\": f\"{nb_params['url']}/graphql/\",\n            \"data\": payload,\n            \"verify\": nb_params.get(\"ssl_verify\", True),\n            \"headers\": {\n                \"Content-Type\": \"application/json\",\n                \"Accept\": \"application/json\",\n                \"Authorization\": f\"Token ...{nb_params['token'][-6:]}\",\n            },\n        }\n\n    # send request to Netbox GraphQL API\n    log.debug(\n        f\"{self.name} - sending GraphQL query '{payload}' to URL '{nb_params['url']}/graphql/'\"\n    )\n    req = requests.post(\n        url=f\"{nb_params['url']}/graphql/\",\n        headers={\n            \"Content-Type\": \"application/json\",\n            \"Accept\": \"application/json\",\n            \"Authorization\": f\"Token {nb_params['token']}\",\n        },\n        data=payload,\n        verify=nb_params.get(\"ssl_verify\", True),\n        timeout=(3, 600),\n    )\n    try:\n        req.raise_for_status()\n    except Exception as e:\n        msg = (\n            f\"{self.name} -  Netbox GraphQL query failed, query '{query}', \"\n            f\"URL '{req.url}', status-code '{req.status_code}', reason '{req.reason}', \"\n            f\"response content '{req.text}'\"\n        )\n        log.error(msg)\n        return msg\n\n    # return results\n    reply = req.json()\n    if reply.get(\"errors\"):\n        log.error(\n            f\"{self.name} - GrapQL query error '{reply['errors']}', query '{payload}'\"\n        )\n        return reply\n    elif queries or query_string:\n        return reply[\"data\"]\n    else:\n        return reply[\"data\"][obj]\n</code></pre>"},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker.get_interfaces","title":"<code>get_interfaces(instance=None, devices=None, ip_addresses=False, inventory_items=False, dry_run=False)</code>","text":"<p>Function to retrieve device interfaces from Netbox using GraphQL API.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>Netbox instance name</p> <code>None</code> <code>devices</code> <code>list</code> <p>list of devices to retrieve interfaces for</p> <code>None</code> <code>ip_addresses</code> <code>bool</code> <p>if True, retrieves interface IPs</p> <code>False</code> <code>inventory_items</code> <code>bool</code> <p>if True, retrieves interface inventory items</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>only return query content, do not run it</p> <code>False</code> <p>Returns:</p> Type Description <p>dictionary keyed by device name with interface details</p> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def get_interfaces(\n    self,\n    instance: str = None,\n    devices: list = None,\n    ip_addresses: bool = False,\n    inventory_items: bool = False,\n    dry_run: bool = False,\n):\n    \"\"\"\n    Function to retrieve device interfaces from Netbox using GraphQL API.\n\n    :param instance: Netbox instance name\n    :param devices: list of devices to retrieve interfaces for\n    :param ip_addresses: if True, retrieves interface IPs\n    :param inventory_items: if True, retrieves interface inventory items\n    :param dry_run: only return query content, do not run it\n    :return: dictionary keyed by device name with interface details\n    \"\"\"\n    # form final result dictionary\n    ret = {d: {} for d in devices}\n    intf_fields = [\n        \"name\",\n        \"enabled\",\n        \"description\",\n        \"mtu\",\n        \"parent {name}\",\n        \"mac_address\",\n        \"mode\",\n        \"untagged_vlan {vid name}\",\n        \"vrf {name}\",\n        \"tagged_vlans {vid name}\",\n        \"tags {name}\",\n        \"custom_fields\",\n        \"last_updated\",\n        \"bridge {name}\",\n        \"child_interfaces {name}\",\n        \"bridge_interfaces {name}\",\n        \"member_interfaces {name}\",\n        \"wwn\",\n        \"duplex\",\n        \"speed\",\n        \"id\",\n        \"device {name}\",\n    ]\n\n    # add IP addresses to interfaces fields\n    if ip_addresses:\n        intf_fields.append(\n            \"ip_addresses {address status role dns_name description custom_fields last_updated tenant {name} tags {name}}\"\n        )\n\n    # form interfaces query dictionary\n    queries = {\n        \"interfaces\": {\n            \"obj\": \"interface_list\",\n            \"filters\": {\"device\": devices},\n            \"fields\": intf_fields,\n        }\n    }\n\n    # add query to retrieve inventory items\n    if inventory_items:\n        inv_filters = {\"device\": devices, \"component_type\": \"dcim.interface\"}\n        inv_fields = [\n            \"name\",\n            \"component {... on InterfaceType {id}}\",\n            \"role {name}\",\n            \"manufacturer {name}\",\n            \"custom_fields\",\n            \"label\",\n            \"description\",\n            \"tags {name}\",\n            \"asset_tag\",\n            \"serial\",\n            \"part_id\",\n        ]\n        queries[\"inventor_items\"] = {\n            \"obj\": \"inventory_item_list\",\n            \"filters\": inv_filters,\n            \"fields\": inv_fields,\n        }\n\n    interfaces_data = self.graphql(\n        instance=instance, queries=queries, dry_run=dry_run\n    )\n\n    # return dry run result\n    if dry_run:\n        return interfaces_data\n\n    # exit if no Interfaces returned\n    if not interfaces_data.get(\"interfaces\"):\n        log.error(\n            f\"{self.name} - no interfaces data in '{interfaces_data}' returned by '{instance}' \"\n            f\"for devices {', '.join(devices)}\"\n        )\n        return ret\n\n    # process query results\n    interfaces = interfaces_data.pop(\"interfaces\")\n\n    # process inventory items\n    if inventory_items:\n        inventory_items_list = interfaces_data.pop(\"inventor_items\")\n        # transform inventory items list to a dictionary keyed by intf_id\n        inventory_items_dict = {}\n        while inventory_items_list:\n            inv_item = inventory_items_list.pop()\n            # skip inventory items that does not assigned to components\n            if inv_item.get(\"component\") is None:\n                continue\n            intf_id = str(inv_item.pop(\"component\").pop(\"id\"))\n            inventory_items_dict.setdefault(intf_id, [])\n            inventory_items_dict[intf_id].append(inv_item)\n        # iterate over interfaces and add inventory items\n        for intf in interfaces:\n            intf[\"inventory_items\"] = inventory_items_dict.pop(intf[\"id\"], [])\n\n    # transform interfaces list to dictionary keyed by device and interfaces names\n    while interfaces:\n        intf = interfaces.pop()\n        _ = intf.pop(\"id\")\n        device_name = intf.pop(\"device\").pop(\"name\")\n        intf_name = intf.pop(\"name\")\n        if device_name in ret:  # Netbox issue #16299\n            ret[device_name][intf_name] = intf\n\n    return ret\n</code></pre>"},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker.get_devices","title":"<code>get_devices(filters=None, instance=None, dry_run=False, devices=None)</code>","text":"<p>Function to retrieve devices data from Netbox using GraphQL API.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>list</code> <p>list of filters dictionaries to filter devices</p> <code>None</code> <code>instance</code> <code>str</code> <p>Netbox instance name</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>only return query content, do not run it</p> <code>False</code> <code>devices</code> <code>list</code> <p>list of device names to query data for</p> <code>None</code> <p>Returns:</p> Type Description <p>dictionary keyed by device name with device data</p> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def get_devices(\n    self,\n    filters: list = None,\n    instance: str = None,\n    dry_run: bool = False,\n    devices: list = None,\n):\n    \"\"\"\n    Function to retrieve devices data from Netbox using GraphQL API.\n\n    :param filters: list of filters dictionaries to filter devices\n    :param instance: Netbox instance name\n    :param dry_run: only return query content, do not run it\n    :param devices: list of device names to query data for\n    :return: dictionary keyed by device name with device data\n    \"\"\"\n    instance = instance or self.default_instance\n    ret = {}\n    filters = filters or []\n    nb_status = self.get_netbox_status(instance)\n\n    # form netbox version\n    NB_VERSION = nb_status[instance][\"netbox-version\"].split(\".\")\n    NB_VERSION = float(\".\".join(NB_VERSION[:2]))\n\n    device_fields = [\n        \"name\",\n        \"last_updated\",\n        \"custom_field_data\",\n        \"tags {name}\",\n        \"device_type {model}\",\n        \"device_role {name}\" if NB_VERSION &lt; 3.6 else \"role {name}\",\n        \"config_context\",\n        \"tenant {name}\",\n        \"platform {name}\",\n        \"serial\",\n        \"asset_tag\",\n        \"site {name tags{name}}\",\n        \"location {name}\",\n        \"rack {name}\",\n        \"status\",\n        \"primary_ip4 {address}\",\n        \"primary_ip6 {address}\",\n        \"airflow\",\n        \"position\",\n    ]\n\n    # form queries dictionary out of filters\n    queries = {\n        f\"devices_by_filter_{index}\": {\n            \"obj\": \"device_list\",\n            \"filters\": filter_item,\n            \"fields\": device_fields,\n        }\n        for index, filter_item in enumerate(filters)\n    }\n\n    # add devices list query\n    if devices:\n        dlist = '[\"{dl}\"]'.format(dl='\", \"'.join(devices))\n        queries[\"devices_by_devices_list\"] = {\n            \"obj\": \"device_list\",\n            \"filters\": {\"name\": f\"{{in_list: {dlist}}}\"},\n            \"fields\": device_fields,\n        }\n\n    # send queries\n    devices_query_result = self.graphql(\n        queries=queries, instance=instance, dry_run=dry_run\n    )\n\n    # return dry run result\n    if dry_run:\n        return devices_query_result\n\n    # check for errors\n    if devices_query_result.get(\"errors\"):\n        log.error(\n            f\"{self.name} - get devices query failed with errors: {devices_query_result['errors']}\"\n        )\n        return ret\n\n    # process devices\n    for devices_list in devices_query_result.values():\n        for device in devices_list:\n            if device[\"name\"] not in ret:\n                ret[device.pop(\"name\")] = device\n\n    return ret\n</code></pre>"},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker.get_connections","title":"<code>get_connections(instance=None, devices=None, dry_run=False, cables=False, circuits=False)</code>","text":"<p>Function to retrieve device connections data from Netbox using GraphQL API.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>Netbox instance name</p> <code>None</code> <code>devices</code> <code>list</code> <p>list of devices to retrieve interface for</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>only return query content, do not run it</p> <code>False</code> <code>cables</code> <code>bool</code> <p>if True includes interfaces' directly attached cables details</p> <code>False</code> <code>circuits</code> <code>bool</code> <p>if True includes interfaces' circuits termination details</p> <code>False</code> <p>Returns:</p> Type Description <p>dictionary keyed by device name with connections data</p> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def get_connections(\n    self,\n    instance: str = None,\n    devices: list = None,\n    dry_run: bool = False,\n    cables: bool = False,\n    circuits: bool = False,\n):\n    \"\"\"\n    Function to retrieve device connections data from Netbox using GraphQL API.\n\n    :param instance: Netbox instance name\n    :param devices: list of devices to retrieve interface for\n    :param dry_run: only return query content, do not run it\n    :param cables: if True includes interfaces' directly attached cables details\n    :param circuits: if True includes interfaces' circuits termination details\n    :return: dictionary keyed by device name with connections data\n    \"\"\"\n    # form final result dictionary\n    connections_dict = {d: {} for d in devices}\n\n    # form lists of fields to request from netbox\n    cable_fields = \"\"\"\n        cable {\n            type\n            status\n            tenant {name}\n            label\n            tags {name}\n            length\n            length_unit\n            custom_fields\n        }\n    \"\"\"\n    interfaces_fields = [\n        \"name\",\n        \"device {name}\",\n        \"\"\"connected_endpoints {\n          __typename \n          ... on InterfaceType {name device {name}}\n          ... on ProviderNetworkType {name}\n        }\"\"\",\n    ]\n    console_ports_fields = [\n        \"name\",\n        \"device {name}\",\n        \"\"\"connected_endpoints {\n          __typename \n          ... on ConsoleServerPortType {name device {name}}\n        }\"\"\",\n        \"\"\"link_peers {\n          __typename\n          ... on ConsoleServerPortType {name device {name}}\n          ... on FrontPortType {name device {name}}\n          ... on RearPortType {name device {name}}\n        }\"\"\",\n    ]\n    console_server_ports_fields = [\n        \"name\",\n        \"device {name}\",\n        \"\"\"connected_endpoints {\n          __typename \n          ... on ConsolePortType {name device {name}}\n        }\"\"\",\n        \"\"\"link_peers {\n          __typename\n          ... on ConsolePortType {name device {name}}\n          ... on FrontPortType {name device {name}}\n          ... on RearPortType {name device {name}}\n        }\"\"\",\n    ]\n\n    # add circuits info\n    if circuits is True:\n        interfaces_fields.append(\n            \"\"\"\n            link_peers {\n                __typename\n                ... on InterfaceType {name device {name}}\n                ... on FrontPortType {name device {name}}\n                ... on RearPortType {name device {name}}\n                ... on CircuitTerminationType {\n                    circuit{\n                        cid \n                        description \n                        tags{name} \n                        provider{name} \n                        status\n                        custom_fields\n                        commit_rate\n                    }\n                }\n            }\n        \"\"\"\n        )\n    else:\n        interfaces_fields.append(\n            \"\"\"\n            link_peers {\n                __typename\n                ... on InterfaceType {name device {name}}\n                ... on FrontPortType {name device {name}}\n                ... on RearPortType {name device {name}}\n            }\n        \"\"\"\n        )\n\n    # check if need to include cables info\n    if cables is True:\n        interfaces_fields.append(cable_fields)\n        console_ports_fields.append(cable_fields)\n        console_server_ports_fields.append(cable_fields)\n\n    # form query dictionary with aliases to get data from Netbox\n    queries = {\n        \"interface\": {\n            \"obj\": \"interface_list\",\n            \"filters\": {\"device\": devices},\n            \"fields\": interfaces_fields,\n        },\n        \"consoleport\": {\n            \"obj\": \"console_port_list\",\n            \"filters\": {\"device\": devices},\n            \"fields\": console_ports_fields,\n        },\n        \"consoleserverport\": {\n            \"obj\": \"console_server_port_list\",\n            \"filters\": {\"device\": devices},\n            \"fields\": console_server_ports_fields,\n        },\n    }\n\n    # retrieve full list of devices interface with all cables\n    all_ports = self.graphql(queries=queries, instance=instance, dry_run=dry_run)\n\n    # return dry run result\n    if dry_run:\n        return all_ports\n\n    # extract interfaces\n    for port_type, ports in all_ports.items():\n        for port in ports:\n            endpoints = port[\"connected_endpoints\"]\n            # skip ports that have no remote device connected\n            if not endpoints or not all(i for i in endpoints):\n                continue\n\n            # extract required parameters\n            cable = port.get(\"cable\", {})\n            device_name = port[\"device\"][\"name\"]\n            port_name = port[\"name\"]\n            link_peers = port[\"link_peers\"]\n            remote_termination_type = endpoints[0][\"__typename\"].lower()\n            remote_termination_type = remote_termination_type.replace(\"type\", \"\")\n\n            # form initial connection dictionary\n            connection = {\n                \"breakout\": len(endpoints) &gt; 1,\n                \"remote_termination_type\": remote_termination_type,\n                \"termination_type\": port_type,\n            }\n\n            # add remote connection details\n            if remote_termination_type == \"providernetwork\":\n                connection[\"remote_device\"] = None\n                connection[\"remote_interface\"] = None\n                connection[\"provider\"] = endpoints[0][\"name\"]\n            else:\n                remote_interface = endpoints[0][\"name\"]\n                if len(endpoints) &gt; 1:\n                    remote_interface = [i[\"name\"] for i in endpoints]\n                connection[\"remote_interface\"] = remote_interface\n                connection[\"remote_device\"] = endpoints[0][\"device\"][\"name\"]\n\n            # handle circuits\n            if (\n                circuits and \"circuit\" in link_peers[0]\n            ):  # add circuit connection details\n                connection[\"circuit\"] = link_peers[0][\"circuit\"]\n\n            # add cable and its peer details\n            if cables:\n                peer_termination_type = link_peers[0][\"__typename\"].lower()\n                peer_termination_type = peer_termination_type.replace(\"type\", \"\")\n                cable[\"peer_termination_type\"] = peer_termination_type\n                cable[\"peer_device\"] = link_peers[0].get(\"device\", {}).get(\"name\")\n                cable[\"peer_interface\"] = link_peers[0].get(\"name\")\n                if len(link_peers) &gt; 1:  # handle breakout cable\n                    cable[\"peer_interface\"] = [i[\"name\"] for i in link_peers]\n                connection[\"cable\"] = cable\n\n            connections_dict[device_name][port_name] = connection\n\n    return connections_dict\n</code></pre>"},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker.get_circuits","title":"<code>get_circuits(instance=None, devices=None, dry_run=False)</code>","text":"<p>Function to retrieve device circuits data from Netbox using GraphQL API.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>str</code> <p>Netbox instance name</p> <code>None</code> <code>devices</code> <code>list</code> <p>list of devices to retrieve interface for</p> <code>None</code> <code>dry_run</code> <code>bool</code> <p>only return query content, do not run it</p> <code>False</code> <p>Returns:</p> Type Description <p>dictionary keyed by device name with circuits data</p> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def get_circuits(\n    self,\n    instance: str = None,\n    devices: list = None,\n    dry_run: bool = False,\n):\n    \"\"\"\n    Function to retrieve device circuits data from Netbox using GraphQL API.\n\n    :param instance: Netbox instance name\n    :param devices: list of devices to retrieve interface for\n    :param dry_run: only return query content, do not run it\n    :return: dictionary keyed by device name with circuits data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"netbox_worker_api_reference/#norfab.workers.netbox_worker.NetboxWorker.get_nornir_inventory","title":"<code>get_nornir_inventory(filters=None, devices=None, instance=None, interfaces=False, connections=False, circuits=False, nbdata=False, primary_ip='ip4')</code>","text":"<p>Method to query Netbox and return devices data in Nornir inventory format.</p> Source code in <code>norfab\\workers\\netbox_worker.py</code> <pre><code>def get_nornir_inventory(\n    self,\n    filters: list = None,\n    devices: list = None,\n    instance: str = None,\n    interfaces: Union[dict, bool] = False,\n    connections: bool = False,\n    circuits: bool = False,\n    nbdata: bool = False,\n    primary_ip: str = \"ip4\",\n):\n    \"\"\"\n    Method to query Netbox and return devices data in Nornir inventory format.\n    \"\"\"\n    hosts = {}\n    inventory = {\"hosts\": hosts}\n\n    # check Netbox status\n    netbox_status = self.get_netbox_status(instance=instance)\n    if netbox_status[instance or self.default_instance][\"status\"] is False:\n        return inventory\n\n    # retrieve devices data\n    nb_devices = self.get_devices(\n        filters=filters, devices=devices, instance=instance\n    )\n\n    # form Nornir hosts inventory\n    for device_name, device in nb_devices.items():\n        host = device[\"config_context\"].pop(\"nornir\", {})\n        host.setdefault(\"data\", {})\n        name = host.pop(\"name\", device_name)\n        hosts[name] = host\n        # add platform if not provided in device config context\n        if not host.get(\"platform\"):\n            if device[\"platform\"]:\n                host[\"platform\"] = device[\"platform\"][\"name\"]\n            else:\n                log.warning(f\"{self.name} - no platform found for '{name}' device\")\n        # add hostname if not provided in config context\n        if not host.get(\"hostname\"):\n            if device[\"primary_ip4\"] and primary_ip in [\"ip4\", \"ipv4\"]:\n                host[\"hostname\"] = device[\"primary_ip4\"][\"address\"].split(\"/\")[0]\n            elif device[\"primary_ip6\"] and primary_ip in [\"ip6\", \"ipv6\"]:\n                host[\"hostname\"] = device[\"primary_ip6\"][\"address\"].split(\"/\")[0]\n            else:\n                host[\"hostname\"] = name\n        # add netbox data to host's data\n        if nbdata is True:\n            host[\"data\"].update(device)\n\n    # add interfaces data\n    if interfaces:\n        # decide on get_interfaces arguments\n        kwargs = interfaces if isinstance(interfaces, dict) else {}\n        # add 'interfaces' key to all hosts' data\n        for host in hosts.values():\n            host[\"data\"].setdefault(\"interfaces\", {})\n        # query interfaces data from netbox\n        nb_interfaces = self.get_interfaces(\n            devices=list(hosts), instance=instance, **kwargs\n        )\n        # save interfaces data to hosts' inventory\n        while nb_interfaces:\n            device, device_interfaces = nb_interfaces.popitem()\n            hosts[device][\"data\"][\"interfaces\"] = device_interfaces\n\n    # add connections data\n    if connections:\n        # decide on get_interfaces arguments\n        kwargs = connections if isinstance(connections, dict) else {}\n        # add 'connections' key to all hosts' data\n        for host in hosts.values():\n            host[\"data\"].setdefault(\"connections\", {})\n        # query connections data from netbox\n        nb_connections = self.get_connections(\n            devices=list(hosts), instance=instance, **kwargs\n        )\n        # save interfaces data to hosts' inventory\n        while nb_connections:\n            device, device_connections = nb_connections.popitem()\n            hosts[device][\"data\"][\"connections\"] = device_connections\n\n    # add circuits data\n    if circuits is True:\n        pass\n\n    return inventory\n</code></pre>"},{"location":"nfcli_client_api_reference/","title":"NFCLI (PICLE Shell) Client","text":""},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client--picle-shell-client","title":"PICLE Shell CLient","text":"<p>Client that implements interactive shell to work with NorFab.</p>"},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client.FileServiceCommands","title":"<code>FileServiceCommands</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client.FileServiceCommands--sample-usage","title":"Sample Usage","text":""},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client.FileServiceCommands--copy","title":"copy","text":"<p>Copy to client's fetched files directory:</p> <p><code>file copy_ url nf://cli/commands.txt</code></p> <p>Copy file to destination relative to current directory</p> <p><code>file copy_ url nf://cli/commands.txt destination commands.txt</code></p>"},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client.FileServiceCommands--list","title":"list","text":"<p>List files at broker root directory:</p> <p><code>file list file list url nf://</code></p> <p>List files details:</p> <pre><code>file details\nfile details url nf://\n</code></pre>"},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client.NorFabShell","title":"<code>NorFabShell</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"nfcli_client_api_reference/#norfab.clients.picle_shell_client.NorFabShell.cmd_preloop_override","title":"<code>cmd_preloop_override()</code>  <code>classmethod</code>","text":"<p>This method called before CMD loop starts</p> Source code in <code>norfab\\clients\\picle_shell_client.py</code> <pre><code>@classmethod\ndef cmd_preloop_override(self):\n    \"\"\"This method called before CMD loop starts\"\"\"\n    pass\n</code></pre>"},{"location":"norfab_architecture/","title":"NORFAB Architecture","text":""},{"location":"norfab_architecture/#high-level-design","title":"High Level Design","text":""},{"location":"norfab_architecture/#low-level-design","title":"Low Level Design","text":"<p>Low level design revolves around resource oriented services - services that manage resources, where resources could be databases, network devices, file system etc.</p> <p></p>"},{"location":"norfab_architecture/#jobs-execution-flow","title":"Jobs Execution Flow","text":"<p>There are multiple job flows implemented:</p> <ul> <li>JOB POST FLOW - for clients to publish jobs to workers</li> <li>JOB LOOP - job execution performed by workers</li> <li>JOB GET FLOW - for clients to retrieve job execution results</li> </ul> <p>Above flows depicted on the diagram.</p> <p></p>"},{"location":"norfab_broker_reference/","title":"Broker","text":"<p>Majordomo Protocol broker A minimal implementation of http:#rfc.zeromq.org/spec:7 and spec:8</p> <p>Author: Min RK benjaminrk@gmail.com Based on Java example by Arkadiusz Orzechowski</p>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPService","title":"<code>NFPService(name)</code>","text":"<p>               Bases: <code>object</code></p> <p>A single NFP Service</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def __init__(self, name: str):\n    self.name = name  # Service name\n    self.workers = []  # list of known workers\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPWorker","title":"<code>NFPWorker(address, socket, socket_lock, multiplier, keepalive, service=None, log_level='WARNING')</code>","text":"<p>               Bases: <code>object</code></p> <p>An NFP Worker convenience class</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def __init__(\n    self,\n    address: str,\n    socket,\n    socket_lock,\n    multiplier: int,  # e.g. 6 times\n    keepalive: int,  # e.g. 5000 ms\n    service: NFPService = None,\n    log_level: str = \"WARNING\",\n):\n    self.address = address  # Address to route to\n    self.service = service\n    self.ready = False\n    self.socket = socket\n    self.exit_event = threading.Event()\n    self.keepalive = keepalive\n    self.multiplier = multiplier\n    self.socket_lock = socket_lock\n    self.log_level = log_level\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPWorker.is_ready","title":"<code>is_ready()</code>","text":"<p>True if worker signaled W.READY</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def is_ready(self):\n    \"\"\"True if worker signaled W.READY\"\"\"\n    return self.service is not None and self.ready is True\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPWorker.destroy","title":"<code>destroy(disconnect=False)</code>","text":"<p>Clean up routine</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def destroy(self, disconnect=False):\n    \"\"\"Clean up routine\"\"\"\n    self.exit_event.set()\n    self.keepaliver.stop()\n    self.service.workers.remove(self)\n\n    if disconnect is True:\n        msg = [self.address, b\"\", NFP.WORKER, self.service.name, NFP.DISCONNECT]\n        with self.socket_lock:\n            self.socket.send_multipart(msg)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker","title":"<code>NFPBroker(endpoint, exit_event, inventory, log_level='WARNING', multiplier=6, keepalive=2500, base_dir='')</code>","text":"<p>NORFAB Protocol broker</p> <p>Initialize broker state.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def __init__(\n    self,\n    endpoint: str,\n    exit_event: Event,\n    inventory: NorFabInventory,\n    log_level: str = \"WARNING\",\n    multiplier: int = 6,\n    keepalive: int = 2500,\n    base_dir: str = \"\",\n):\n    \"\"\"Initialize broker state.\"\"\"\n    log.setLevel(log_level.upper())\n    self.log_level = log_level\n    self.keepalive = keepalive\n    self.multiplier = multiplier\n\n    self.services = {}\n    self.workers = {}\n    self.exit_event = exit_event\n    self.inventory = inventory\n\n    self.ctx = zmq.Context()\n    self.socket = self.ctx.socket(zmq.ROUTER)\n    self.socket.linger = 0\n    self.poller = zmq.Poller()\n    self.poller.register(self.socket, zmq.POLLIN)\n    self.socket.bind(endpoint)\n    self.socket_lock = (\n        threading.Lock()\n    )  # used for keepalives to protect socket object\n\n    self.base_dir = base_dir or os.getcwd()\n    os.makedirs(self.base_dir, exist_ok=True)\n\n    log.debug(f\"NFPBroker - is read and listening on {endpoint}\")\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.mediate","title":"<code>mediate()</code>","text":"<p>Main broker work happens here</p> <p>Client send messages of this frame format:</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def mediate(self):\n    \"\"\"\n    Main broker work happens here\n\n    Client send messages of this frame format:\n\n\n    \"\"\"\n    while True:\n        try:\n            items = self.poller.poll(self.keepalive)\n        except KeyboardInterrupt:\n            break  # Interrupted\n\n        if items:\n            msg = self.socket.recv_multipart()\n            log.debug(f\"NFPBroker - received '{msg}'\")\n\n            sender = msg.pop(0)\n            empty = msg.pop(0)\n            header = msg.pop(0)\n\n            if header == NFP.CLIENT:\n                self.process_client(sender, msg)\n            elif header == NFP.WORKER:\n                self.process_worker(sender, msg)\n\n        self.purge_workers()\n\n        # check if need to stop\n        if self.exit_event.is_set():\n            self.destroy()\n            break\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.destroy","title":"<code>destroy()</code>","text":"<p>Disconnect all workers, destroy context.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def destroy(self):\n    \"\"\"Disconnect all workers, destroy context.\"\"\"\n    log.info(f\"NFPBroker - interrupt received, killing broker\")\n    for name in list(self.workers.keys()):\n        # in case worker self destroyed while we iterating\n        if self.workers.get(name):\n            self.delete_worker(self.workers[name], True)\n    self.ctx.destroy(0)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.delete_worker","title":"<code>delete_worker(worker, disconnect)</code>","text":"<p>Deletes worker from all data structures, and deletes worker.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def delete_worker(self, worker, disconnect):\n    \"\"\"Deletes worker from all data structures, and deletes worker.\"\"\"\n    worker.destroy(disconnect)\n    self.workers.pop(worker.address, None)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.purge_workers","title":"<code>purge_workers()</code>","text":"<p>Look for &amp; delete expired workers.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def purge_workers(self):\n    \"\"\"Look for &amp; delete expired workers.\"\"\"\n    for name in list(self.workers.keys()):\n        # in case worker self destroyed while we iterating\n        if self.workers.get(name):\n            w = self.workers[name]\n        if not w.keepaliver.is_alive():\n            self.delete_worker(w, False)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.send_to_worker","title":"<code>send_to_worker(worker, command, sender, uuid, data)</code>","text":"<p>Send message to worker. If message is provided, sends that message.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def send_to_worker(\n    self, worker: NFPWorker, command: bytes, sender: bytes, uuid: bytes, data: bytes\n):\n    \"\"\"Send message to worker. If message is provided, sends that message.\"\"\"\n    # Stack routing and protocol envelopes to start of message\n    if command == NFP.POST:\n        msg = [worker.address, b\"\", NFP.WORKER, NFP.POST, sender, b\"\", uuid, data]\n    elif command == NFP.GET:\n        msg = [worker.address, b\"\", NFP.WORKER, NFP.GET, sender, b\"\", uuid, data]\n    else:\n        log.error(f\"NFPBroker - invalid worker command: {command}\")\n        return\n    with self.socket_lock:\n        log.debug(f\"NFPBroker - sending to worker '{msg}'\")\n        self.socket.send_multipart(msg)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.send_to_client","title":"<code>send_to_client(client, command, service, message)</code>","text":"<p>Send message to client.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def send_to_client(self, client: str, command: str, service: str, message: list):\n    \"\"\"Send message to client.\"\"\"\n    # Stack routing and protocol envelopes to start of message\n    if command == NFP.RESPONSE:\n        msg = [client, b\"\", NFP.CLIENT, NFP.RESPONSE, service] + message\n    else:\n        log.error(f\"NFPBroker - invalid client command: {command}\")\n        return\n    with self.socket_lock:\n        log.debug(f\"NFPBroker - sending to client '{msg}'\")\n        self.socket.send_multipart(msg)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.process_worker","title":"<code>process_worker(sender, msg)</code>","text":"<p>Process message received from worker.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def process_worker(self, sender, msg):\n    \"\"\"Process message received from worker.\"\"\"\n    command = msg.pop(0)\n    worker = self.require_worker(sender)\n\n    if NFP.READY == command and not worker.is_ready():\n        service = msg.pop(0)\n        worker.service = self.require_service(service)\n        worker.ready = True\n        worker.start_keepalives()\n        worker.service.workers.append(worker)\n    elif NFP.RESPONSE == command and worker.is_ready():\n        client = msg.pop(0)\n        empty = msg.pop(0)\n        self.send_to_client(client, NFP.RESPONSE, worker.service.name, msg)\n    elif NFP.KEEPALIVE == command:\n        worker.keepaliver.received_heartbeat([worker.address] + msg)\n    elif NFP.DISCONNECT == command and worker.is_ready():\n        self.delete_worker(worker, False)\n    elif not worker.is_ready():\n        self.delete_worker(worker, disconnect=True)\n    else:\n        log.error(f\"NFPBroker - invalid message: {msg}\")\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.require_worker","title":"<code>require_worker(address)</code>","text":"<p>Finds the worker, creates if necessary.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def require_worker(self, address):\n    \"\"\"Finds the worker, creates if necessary.\"\"\"\n    if not self.workers.get(address):\n        self.workers[address] = NFPWorker(\n            address=address,\n            socket=self.socket,\n            multiplier=self.multiplier,\n            keepalive=self.keepalive,\n            socket_lock=self.socket_lock,\n            log_level=self.log_level,\n        )\n        log.info(f\"NFPBroker - registered new worker {address}\")\n\n    return self.workers[address]\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.require_service","title":"<code>require_service(name)</code>","text":"<p>Locates the service (creates if necessary).</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def require_service(self, name):\n    \"\"\"Locates the service (creates if necessary).\"\"\"\n    if not self.services.get(name):\n        service = NFPService(name)\n        self.services[name] = service\n        log.debug(f\"NFPBroker - registered new service {name}\")\n\n    return self.services[name]\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.process_client","title":"<code>process_client(sender, msg)</code>","text":"<p>Process a request coming from a client.</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def process_client(self, sender, msg):\n    \"\"\"Process a request coming from a client.\"\"\"\n    command = msg.pop(0)\n    service = msg.pop(0)\n    target = msg.pop(0)\n    uuid = msg.pop(0)\n    data = msg.pop(0)\n\n    # check if valid command from client\n    if command not in NFP.client_commands:\n        message = f\"NFPBroker - Unsupported client command '{command}'\"\n        log.error(message)\n        self.send_to_client(\n            sender, NFP.RESPONSE, service, [message.encode(\"utf-8\")]\n        )\n    # Management Interface\n    elif service == b\"mmi.service.broker\":\n        self.mmi_service(sender, command, target, uuid, data)\n    elif service == b\"sid.service.broker\":\n        self.inventory_service(sender, command, target, uuid, data)\n    elif service == b\"fss.service.broker\":\n        self.file_sharing_service(sender, command, target, uuid, data)\n    else:\n        self.dispatch(\n            sender, command, self.require_service(service), target, uuid, data\n        )\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.filter_workers","title":"<code>filter_workers(target, service)</code>","text":"<p>Helper function to filter workers</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>bytes</code> <p>bytest string, workers target</p> required <code>service</code> <code>NFPService</code> <p>NFPService object</p> required Source code in <code>norfab\\core\\broker.py</code> <pre><code>def filter_workers(self, target: bytes, service: NFPService) -&gt; list:\n    \"\"\"\n    Helper function to filter workers\n\n    :param target: bytest string, workers target\n    :param service: NFPService object\n    \"\"\"\n    ret = []\n    if not service.workers:\n        log.warning(\n            f\"NFPBroker - '{service.name}' has no active workers registered, try later\"\n        )\n        ret = []\n    elif target == b\"any\":\n        ret = [service.workers[random.randint(0, len(service.workers) - 1)]]\n    elif target == b\"all\":\n        ret = service.workers\n    elif target in self.workers:  # single worker\n        ret = [self.workers[target]]\n    else:  # target list of workers\n        try:\n            target = json.loads(target)\n            if isinstance(target, list):\n                for w in target:\n                    w = w.encode(\"utf-8\")\n                    if w in self.workers:\n                        ret.append(self.workers[w])\n                ret = list(set(ret))  # dedup workers\n        except Exception as e:\n            log.error(\n                f\"NFPBroker - Failed to load target '{target}' with error '{e}'\"\n            )\n    return ret\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.dispatch","title":"<code>dispatch(sender, command, service, target, uuid, data)</code>","text":"<p>Dispatch requests to waiting workers as possible</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <p>service object</p> required <code>target</code> <p>string indicating workers addresses to dispatch to</p> required <code>msg</code> <p>string with work request content</p> required Source code in <code>norfab\\core\\broker.py</code> <pre><code>def dispatch(self, sender, command, service, target, uuid, data):\n    \"\"\"\n    Dispatch requests to waiting workers as possible\n\n    :param service: service object\n    :param target: string indicating workers addresses to dispatch to\n    :param msg: string with work request content\n    \"\"\"\n    log.debug(\n        f\"NFPBroker - dispatching request to workers: sender '{sender}', \"\n        f\"command '{command}', service '{service.name}', target '{target}'\"\n        f\"data '{data}', uuid '{uuid}'\"\n    )\n    self.purge_workers()\n    workers = self.filter_workers(target, service)\n\n    # handle case when service has no workers registered\n    if not workers:\n        message = f\"NFPBroker - {service.name} service failed to target workers '{target}'\"\n        log.error(message)\n        self.send_to_client(\n            sender,\n            NFP.RESPONSE,\n            service.name,\n            [uuid, b\"400\", message.encode(\"utf-8\")],\n        )\n    else:\n        # inform client that JOB dispatched\n        w_addresses = [w.address.decode(\"utf-8\") for w in workers]\n        self.send_to_client(\n            sender,\n            NFP.RESPONSE,\n            service.name,\n            [\n                uuid,\n                b\"202\",\n                json.dumps(\n                    {\n                        \"workers\": w_addresses,\n                        \"uuid\": uuid.decode(\"utf-8\"),\n                        \"target\": target.decode(\"utf-8\"),\n                        \"status\": \"DISPATCHED\",\n                        \"service\": service.name.decode(\"utf-8\"),\n                    }\n                ).encode(\"utf-8\"),\n            ],\n        )\n        # send job to workers\n        for worker in workers:\n            self.send_to_worker(worker, command, sender, uuid, data)\n</code></pre>"},{"location":"norfab_broker_reference/#norfab.core.broker.NFPBroker.mmi_service","title":"<code>mmi_service(sender, command, target, uuid, data)</code>","text":"<p>Handle internal service according to 8/MMI specification</p> Source code in <code>norfab\\core\\broker.py</code> <pre><code>def mmi_service(self, sender, command, target, uuid, data):\n    \"\"\"Handle internal service according to 8/MMI specification\"\"\"\n    log.debug(\n        f\"mmi.service.broker - processing request: sender '{sender}', \"\n        f\"command '{command}', target '{target}'\"\n        f\"data '{data}', uuid '{uuid}'\"\n    )\n    data = json.loads(data)\n    task = data.get(\"task\")\n    args = data.get(\"args\", [])\n    kwargs = data.get(\"kwargs\", {})\n    ret = f\"Unsupported task '{task}'\"\n    if task == \"show_workers\":\n        if self.workers:\n            ret = [\n                {\n                    \"name\": w.address.decode(\"utf-8\"),\n                    \"service\": w.service.name.decode(\"utf-8\"),\n                    \"status\": \"alive\" if w.keepaliver.is_alive() else \"dead\",\n                    \"holdtime\": str(w.keepaliver.show_holdtime()),\n                    \"keepalives tx/rx\": f\"{w.keepaliver.keepalives_send} / {w.keepaliver.keepalives_received}\",\n                    \"alive (s)\": str(w.keepaliver.show_alive_for()),\n                }\n                for k, w in self.workers.items()\n            ]\n            # filter reply\n            service = kwargs.get(\"service\")\n            status = kwargs.get(\"status\")\n            if service and service != \"all\":\n                ret = [w for w in ret if w[\"service\"] == service]\n            if status in [\"alive\", \"dead\"]:\n                ret = [w for w in ret if w[\"status\"] == status]\n            if not ret:\n                ret = [{\"name\": \"\", \"service\": \"\", \"status\": \"\"}]\n        else:\n            ret = [{\"name\": \"\", \"service\": \"\", \"status\": \"\"}]\n    elif task == \"show_broker\":\n        ret = {\n            \"address\": self.socket.getsockopt_string(zmq.LAST_ENDPOINT),\n            \"status\": \"active\",\n            \"multiplier\": self.multiplier,\n            \"keepalive\": self.keepalive,\n            \"workers count\": len(self.workers),\n            \"services count\": len(self.services),\n            \"base_dir\": self.base_dir,\n        }\n    reply = json.dumps(ret).encode(\"utf-8\")\n    self.send_to_client(\n        sender, NFP.RESPONSE, b\"mmi.service.broker\", [uuid, b\"200\", reply]\n    )\n</code></pre>"},{"location":"norfab_cli_overview/","title":"NORFAB CLI","text":"<p>NorFab CLI designed as a modal operating system. The term modal  describes a system that has various modes of operation, each having its own  domain of operation. The CLI uses a hierarchical structure for the modes.</p> <p>You can access a lower-level mode only from a higher-level mode. For example,  to access the Nornir mode, you must be in the privileged EXEC mode. Each mode  is used to accomplish particular tasks and has a specific set of commands that  are available in this mode. For example, to configure a router interface, you  must be in Nornir configuration mode. All configurations that you enter in  configuration mode apply only to this function.</p> <p>NorFab CLI build using PICLE package.</p> <p>It is important to remember that in PICLE Shell, when you enter a command, the  command is executed. If you enter an incorrect command in a production environment,  it can negatively affect it.</p>"},{"location":"norfab_exceptions_reference/","title":"Exceptions","text":""},{"location":"norfab_exceptions_reference/#norfab.core.exceptions.UnsupportedPluginError","title":"<code>UnsupportedPluginError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception to raise when specified plugin not supported</p>"},{"location":"norfab_getting_started/","title":"Getting Started","text":"<p>Once NorFab installed, next step is to create a folder that will  hold your environment and start creating inventory files with required configurations.</p> <p>Create <code>nftry</code> folder and inside of it create <code>inventory.yaml</code>  file with this content:</p> inventory.yaml<pre><code>broker: # (1)!\n  endpoint: \"tcp://127.0.0.1:5555\" # (2)!\n\nworkers: # (3)!\n  nornir-*: # (4)!\n    - nornir/common.yaml   \n  nornir-worker-1: # (5)!\n    - nornir/nornir-worker-1.yaml\n\ntopology: # (6)!\n  broker: True # (7)!\n  workers: # (8)!\n    - nornir-worker-1\n</code></pre> <ol> <li>Broker configuration section</li> <li>URL to listen for connections on - <code>localhost</code> port <code>5555</code> in this case</li> <li>Workers configuration section</li> <li>glob pattern that will match      all workers with <code>nornir-</code> in the name and map <code>common.yaml</code> context for      each such a worker</li> <li>Worker definition to map inventory file to a specific worker that has name <code>nornir-worker-1</code></li> <li>Topology section to define what components to run</li> <li>Start broker process</li> <li>Lit of workers names to start processes for</li> </ol> <p>In this example we are working with Nornir service.</p> <p>Create <code>nornir</code> folder and inside of it create two files.</p> <p>First file <code>common.yaml</code> to host configuration common for all Nornir service workers:</p> common.yaml<pre><code>service: nornir # (1)!\nbroker_endpoint: \"tcp://127.0.0.1:5555\" # (2)!\n\n# next comes Nornir inventory and configuration\nrunner: # (3)!\n  plugin: RetryRunner\ndefault: {} # (4)!\ngroups: {} # (5)!\n</code></pre> <ol> <li>Name of the service this worker hosting</li> <li>Broker URL to initiate connections with</li> <li>Nornir runner plugin configuration</li> <li>Nornir <code>default</code> data section</li> <li>Nornir groups definition section</li> </ol> <p>Second file specific to the worker with name <code>nornir-worker-1</code> which holds Nornir inventory data:</p> nornir-worker-1.yaml<pre><code>hosts: \n  R1:\n    hostname: r1.lab.local\n    platform: cisco_ios\n    username: developer\n    password: secretpassword\n  R2:\n    hostname: 10.0.0.2\n    platform: cisco_ios\n    username: developer\n    password: secretpassword\n</code></pre> <p>This is how files structure will look like:</p> <pre><code>\u2514\u2500\u2500\u2500nftry\n    \u2502   inventory.yaml\n    \u2502\n    \u2514\u2500\u2500\u2500nornir\n            common.yaml\n            nornir-worker-1.yaml\n</code></pre> <p>Now you are ready to start NorFab Interactive Command Line Shell  Client - NFCLI. Open terminal window, navigate to the folder  where <code>inventory.yaml</code> located and start NFCLI:</p> <pre><code>C:\\&gt;cd nftry\nC:\\nftry&gt;nfcli\nnf#\n</code></pre> <p>this will start the NorFab broker process, Nornir worker process, instantiate NFCLI client and drop you into interactive command line shell </p> <pre><code>nf#?\n file      File sharing service\n netbox    Netbox service\n nornir    Nornir service\n show      NorFab show commands\n exit      Exit current shell\n help      Print help message\n pwd       Print current shell path\n top       Exit to top shell\nnf#show workers\n name             service  status  holdtime  keepalives tx/rx  alive (s)\n nornir-worker-1  nornir   alive   12.8      58 / 58           149\nnf#\nnf#nornir\nnf[nornir]#?\n task    Run Nornir task\n test    Run network tests\n end     Exit application\n exit    Exit current shell\n help    Print help message\n pwd     Print current shell path\n top     Exit to top shell\nnf[nornir]#show hosts\n {\n     \"nornir-worker-1\": [\n         \"R1\",\n         \"R2\"\n     ]\n }\nnf[nornir]#?\n cfg     Configure devices over CLI interface\n cli     Send CLI commands to devices\n show    Show Nornir service parameters\n task    Run Nornir task\n test    Run network tests\n end     Exit application\n exit    Exit current shell\n help    Print help message\n pwd     Print current shell path\n top     Exit to top shell\nnf[nornir]# end\nExiting...\n</code></pre> <p>NorFab CLI supports Tab completions, question mark help together with sub-shells, read more about NorFab CLI and how to use it here.</p> <p> That's it </p>"},{"location":"norfab_installation/","title":"Installation","text":""},{"location":"norfab_installation/#norfab-core","title":"NorFab Core","text":"<p>Install NorFab core from PyPI</p> <pre><code>pip install norfab\n</code></pre>"},{"location":"norfab_installation/#extras","title":"Extras","text":"<p>Several extra installations supported tailoring certain services dependencies depending on what you want to run on a given node.</p>"},{"location":"norfab_installation/#norfab-cli-dependencies","title":"NORFAB CLI Dependencies","text":"<p>To install NorFab Interactive CLI dependencies</p> <pre><code>pip install norfab[nfcli]\n</code></pre>"},{"location":"norfab_installation/#nornir-service-dependencies","title":"Nornir Service Dependencies","text":"<p>To install Nornir service dependencies</p> <pre><code>pip install norfab[nornir_service]\n</code></pre>"},{"location":"norfab_installation/#netbox-service-dependencies","title":"Netbox Service Dependencies","text":"<p>To install Netbox service dependencies</p> <pre><code>pip install norfab[netbox_service]\n</code></pre>"},{"location":"norfab_inventory_reference/","title":"Simple Inventory","text":"<p>Simple Local Inventory is an inventory plugin to load  inventory data from locally stored files.</p> <p>Sample inventory file</p> <pre><code>broker:\n  endpoint: \"tcp://127.0.0.1:5555\"\n\nworkers:\n  nornir-*:\n    - nornir/common.yaml  \n  nornir-worker-1:\n    - nornir/nornir-worker-1.yaml\n\ntopology:\n  broker: True\n  workers:\n    - nornir-worker-1\n</code></pre> <p>where <code>nornir/common.yaml</code> contains</p> <pre><code>service: nornir\nbroker_endpoint: \"tcp://127.0.0.1:5555\"\nrunner:\n  plugin: RetryRunner\n  options: \n    num_workers: 100\n    num_connectors: 10\n    connect_retry: 3\n    connect_backoff: 1000\n    connect_splay: 100\n    task_retry: 3\n    task_backoff: 1000\n    task_splay: 100\n    reconnect_on_fail: True\n    task_timeout: 600\n</code></pre> <p>and <code>nornir/nornir-worker-1.yaml</code> contains</p> <pre><code>hosts: \n  csr1000v-1:\n    hostname: sandbox-1.lab.com\n    platform: cisco_ios\n    username: developer\n    password: secretpassword\n  csr1000v-2:\n    hostname: sandbox-2.lab.com\n    platform: cisco_ios\n    username: developer\n    password: secretpassword\ngroups: {}\ndefaults: {}\n</code></pre> <p>Whenever inventory queried to provide data for worker with name <code>nornir-worker-1</code> Simple Inventory iterates over <code>workers</code> dictionary and recursively merges  data for keys (glob patterns) that matched worker name.</p>"},{"location":"norfab_inventory_reference/#norfab.core.inventory.WorkersInventory","title":"<code>WorkersInventory(path, data)</code>","text":"<p>Class to collect and server NorFab workers inventory data, forming it by recursively merging all data files that associated with the name of worker requesting inventory data.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>OS path to top folder with workers inventory data</p> required <code>data</code> <code>dict</code> <p>dictionary keyed by glob patterns matching workers names and values being a list of OS paths to files with workers  inventory data</p> required Source code in <code>norfab\\core\\inventory.py</code> <pre><code>def __init__(self, path: str, data: dict) -&gt; None:\n    \"\"\"\n    Class to collect and server NorFab workers inventory data,\n    forming it by recursively merging all data files that associated\n    with the name of worker requesting inventory data.\n\n    :param path: OS path to top folder with workers inventory data\n    :param data: dictionary keyed by glob patterns matching workers names\n        and values being a list of OS paths to files with workers \n        inventory data\n    \"\"\"\n    self.path, _ = os.path.split(path)\n    self.data = data\n</code></pre>"},{"location":"norfab_inventory_reference/#norfab.core.inventory.NorFabInventory","title":"<code>NorFabInventory(path)</code>","text":"<p>NorFabInventory class to instantiate simple inventory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>OS path to YAML file with inventory data</p> required Source code in <code>norfab\\core\\inventory.py</code> <pre><code>def __init__(self, path: str) -&gt; None:\n    \"\"\"\n    NorFabInventory class to instantiate simple inventory.\n\n    :param path: OS path to YAML file with inventory data\n    \"\"\"\n    self.broker = {}\n    self.workers = {}\n    self.topology = {}\n    path = os.path.abspath(path)\n    self.load(path)\n</code></pre>"},{"location":"norfab_inventory_reference/#norfab.core.inventory.merge_recursively","title":"<code>merge_recursively(data, merge)</code>","text":"<p>Function to merge two dictionaries data recursively.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>primary dictionary</p> required <code>merge</code> <code>dict</code> <p>dictionary to merge into primary overriding the content</p> required Source code in <code>norfab\\core\\inventory.py</code> <pre><code>def merge_recursively(data: dict, merge: dict) -&gt; None:\n    \"\"\"\n    Function to merge two dictionaries data recursively.\n\n    :param data: primary dictionary\n    :param merge: dictionary to merge into primary overriding the content\n    \"\"\"\n    assert isinstance(data, dict) and isinstance(\n        merge, dict\n    ), f\"Only supports dictionary/dictionary data merges, not {type(data)}/{type(merge)}\"\n    for k, v in merge.items():\n        if k in data:\n            # merge two lists\n            if isinstance(data[k], list) and isinstance(v, list):\n                for i in v:\n                    if i not in data[k]:\n                        data[k].append(i)\n            # recursively merge dictionaries\n            elif isinstance(data[k], dict) and isinstance(v, dict):\n                merge_recursively(data[k], v)\n            # rewrite existing value with new data\n            else:\n                data[k] = v\n        else:\n            data[k] = v\n</code></pre>"},{"location":"norfab_nfapi_reference/","title":"NFAPI (Python API)","text":"<p>Utility class to implement Python API for interfacing with NorFab.</p> <p>NorFab Python API Client initialization class</p> <pre><code>from norfab.core.nfapi import NorFab\n\nnf = NorFab(inventory=inventory)\nnf.start(start_broker=True, workers=[\"my-worker-1\"])\nNFCLIENT = nf.client\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>inventory</code> <code>str</code> <p>OS path to NorFab inventory YAML file</p> <code>'./inventory.yaml'</code> <code>log_level</code> <code>str</code> <p>one or supported logging levels - <code>CRITICAL</code>, <code>ERROR</code>, <code>WARNING</code>, <code>INFO</code>, <code>DEBUG</code></p> <code>'WARNING'</code> Source code in <code>norfab\\core\\nfapi.py</code> <pre><code>def __init__(self, inventory: str=\"./inventory.yaml\", log_level: str=\"WARNING\") -&gt; None:\n    \"\"\"\n    NorFab Python API Client initialization class\n\n    ```\n    from norfab.core.nfapi import NorFab\n\n    nf = NorFab(inventory=inventory)\n    nf.start(start_broker=True, workers=[\"my-worker-1\"])\n    NFCLIENT = nf.client\n    ```\n\n    :param inventory: OS path to NorFab inventory YAML file\n    :param log_level: one or supported logging levels - `CRITICAL`, `ERROR`, `WARNING`, `INFO`, `DEBUG`\n    \"\"\"\n    self.inventory = NorFabInventory(inventory)\n    self.log_level = log_level\n    self.broker_endpoint = self.inventory.get(\"broker\", {}).get(\"endpoint\")\n    self.workers = {}\n    self.broker_exit_event = Event()\n    self.workers_exit_event = Event()\n    self.services_exit_event = Event()\n</code></pre>"},{"location":"norfab_nfapi_reference/#norfab.core.nfapi.NorFab.start","title":"<code>start(start_broker=None, workers=None)</code>","text":"<p>Main entry method to start NorFab components.</p> <p>Parameters:</p> Name Type Description Default <code>start_broker</code> <code>bool</code> <p>if True, starts broker process</p> <code>None</code> <code>workers</code> <code>list</code> <p>list of worker names to start processes for</p> <code>None</code> Source code in <code>norfab\\core\\nfapi.py</code> <pre><code>def start(\n    self,\n    start_broker: bool = None,\n    workers: list = None,\n):\n    \"\"\"\n    Main entry method to start NorFab components.\n\n    :param start_broker: if True, starts broker process\n    :param workers: list of worker names to start processes for\n    \"\"\"\n    if workers is None:\n        workers = self.inventory.topology.get(\"workers\", [])\n    if start_broker is None:\n        start_broker = self.inventory.topology.get(\"broker\", False)\n\n    # start the broker\n    if start_broker is True:\n        self.start_broker()\n\n    # start all the workers\n    if workers and isinstance(workers, list):\n        for worker_name in workers:\n            try:\n                self.start_worker(worker_name)\n            except KeyError:\n                log.error(f\"No inventory data found for '{worker_name}'\")\n\n    # make the API client\n    self.make_client()\n</code></pre>"},{"location":"norfab_nfapi_reference/#norfab.core.nfapi.NorFab.destroy","title":"<code>destroy()</code>","text":"<p>Stop NORFAB processes.</p> Source code in <code>norfab\\core\\nfapi.py</code> <pre><code>def destroy(self) -&gt; None:\n    \"\"\"\n    Stop NORFAB processes.\n    \"\"\"\n    # stop workers\n    self.workers_exit_event.set()\n    while self.workers:\n        _, w = self.workers.popitem()\n        w.join()\n    # stop broker\n    self.broker_exit_event.set()\n    if self.broker:\n        self.broker.join()\n    # stop client\n    self.client.destroy()\n</code></pre>"},{"location":"norfab_nfapi_reference/#norfab.core.nfapi.NorFab.make_client","title":"<code>make_client(broker_endpoint=None)</code>","text":"<p>Make an instance of NorFab client</p> <p>Parameters:</p> Name Type Description Default <code>broker_endpoint</code> <code>str</code> <p>(str), Broker URL to connect with</p> <code>None</code> Source code in <code>norfab\\core\\nfapi.py</code> <pre><code>def make_client(self, broker_endpoint: str = None) -&gt; NFPClient:\n    \"\"\"\n    Make an instance of NorFab client\n\n    :param broker_endpoint: (str), Broker URL to connect with\n    \"\"\"\n\n    if broker_endpoint or self.broker_endpoint:\n        client = NFPClient(\n            broker_endpoint or self.broker_endpoint, \"NFPClient\", self.log_level\n        )\n        if self.client is None:  # own the first client\n            self.client = client\n        return client\n    else:\n        log.error(\"Failed to make client, no broker endpoint defined\")\n        return None\n</code></pre>"},{"location":"nornir_worker_api_reference/","title":"Nornir Worker","text":""},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker","title":"<code>NornirWorker(broker, service, worker_name, exit_event=None, log_level='WARNING')</code>","text":"<p>               Bases: <code>NFPWorker</code></p> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def __init__(\n    self, broker, service, worker_name, exit_event=None, log_level=\"WARNING\"\n):\n    super().__init__(broker, service, worker_name, exit_event, log_level)\n\n    # get inventory from broker\n    self.inventory = self.load_inventory()\n\n    # pull Nornir inventory from Netbox\n    self._pull_netbox_inventory()\n\n    # initiate Nornir\n    self._initiate_nornir()\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.get_nornir_hosts","title":"<code>get_nornir_hosts(**kwargs)</code>","text":"<p>Produce a list of hosts managed by this worker</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>dictionary of nornir-salt Fx filters</p> <code>{}</code> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def get_nornir_hosts(self, **kwargs: dict) -&gt; list:\n    \"\"\"\n    Produce a list of hosts managed by this worker\n\n    :param kwargs: dictionary of nornir-salt Fx filters\n    \"\"\"\n    filters = {k: kwargs.pop(k) for k in list(kwargs.keys()) if k in FFun_functions}\n    filtered_nornir = FFun(self.nr, **filters)\n    return list(filtered_nornir.inventory.hosts)\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.get_nornir_inventory","title":"<code>get_nornir_inventory(**kwargs)</code>","text":"<p>Retrieve running Nornir inventory for requested hosts</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <code>dict</code> <p>dictionary of nornir-salt Fx filters</p> <code>{}</code> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def get_nornir_inventory(self, **kwargs: dict) -&gt; dict:\n    \"\"\"\n    Retrieve running Nornir inventory for requested hosts\n\n    :param kwargs: dictionary of nornir-salt Fx filters\n    \"\"\"\n    filters = {k: kwargs.pop(k) for k in list(kwargs.keys()) if k in FFun_functions}\n    filtered_nornir = FFun(self.nr, **filters)\n    return filtered_nornir.inventory.dict()\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.get_nornir_version","title":"<code>get_nornir_version()</code>","text":"<p>Produce Python packages version report</p> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def get_nornir_version(self):\n    \"\"\"\n    Produce Python packages version report\n    \"\"\"\n    libs = {\n        \"scrapli\": \"\",\n        \"scrapli-netconf\": \"\",\n        \"scrapli-community\": \"\",\n        \"paramiko\": \"\",\n        \"netmiko\": \"\",\n        \"napalm\": \"\",\n        \"nornir\": \"\",\n        \"ncclient\": \"\",\n        \"nornir-netmiko\": \"\",\n        \"nornir-napalm\": \"\",\n        \"nornir-scrapli\": \"\",\n        \"nornir-utils\": \"\",\n        \"tabulate\": \"\",\n        \"xmltodict\": \"\",\n        \"puresnmp\": \"\",\n        \"pygnmi\": \"\",\n        \"pyyaml\": \"\",\n        \"jmespath\": \"\",\n        \"jinja2\": \"\",\n        \"ttp\": \"\",\n        \"nornir-salt\": \"\",\n        \"lxml\": \"\",\n        \"ttp-templates\": \"\",\n        \"ntc-templates\": \"\",\n        \"cerberus\": \"\",\n        \"pydantic\": \"\",\n        \"requests\": \"\",\n        \"textfsm\": \"\",\n        \"N2G\": \"\",\n        \"dnspython\": \"\",\n        \"pythonping\": \"\",\n        \"python\": sys.version.split(\" \")[0],\n        \"platform\": sys.platform,\n    }\n    # get version of packages installed\n    for pkg in libs.keys():\n        try:\n            libs[pkg] = importlib.metadata.version(pkg)\n        except importlib.metadata.PackageNotFoundError:\n            pass\n\n    return libs\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.task","title":"<code>task(plugin, **kwargs)</code>","text":"<p>Function to invoke any of supported Nornir task plugins. This function performs dynamic import of requested plugin function and executes <code>nr.run</code> using supplied args and kwargs</p> <p><code>plugin</code> attribute can refer to a file to fetch from file service. File must contain function named <code>task</code> accepting Nornir task object as a first positional argument, for example:</p> <pre><code># define connection name for RetryRunner to properly detect it\nCONNECTION_NAME = \"netmiko\"\n\n# create task function\ndef task(nornir_task_object, *args, **kwargs):\n    pass\n</code></pre> <p>CONNECTION_NAME</p> <p><code>CONNECTION_NAME</code> must be defined within custom task function file if RetryRunner in use, otherwise connection retry logic skipped and connections to all hosts initiated simultaneously up to the number of <code>num_workers</code>.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>str</code> <p>(str) <code>path.to.plugin.task_fun</code> to import or <code>nf://path/to/task.py</code> to download custom task</p> required <code>kwargs</code> <p>(dict) arguments to use with specified task plugin</p> <code>{}</code> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def task(self, plugin: str, **kwargs) -&gt; dict:\n    \"\"\"\n    Function to invoke any of supported Nornir task plugins. This function\n    performs dynamic import of requested plugin function and executes\n    ``nr.run`` using supplied args and kwargs\n\n    ``plugin`` attribute can refer to a file to fetch from file service. File must contain\n    function named ``task`` accepting Nornir task object as a first positional\n    argument, for example:\n\n    ```python\n    # define connection name for RetryRunner to properly detect it\n    CONNECTION_NAME = \"netmiko\"\n\n    # create task function\n    def task(nornir_task_object, *args, **kwargs):\n        pass\n    ```\n\n    !!! note \"CONNECTION_NAME\"\n\n        ``CONNECTION_NAME`` must be defined within custom task function file if\n        RetryRunner in use, otherwise connection retry logic skipped and connections\n        to all hosts initiated simultaneously up to the number of ``num_workers``.\n\n    :param plugin: (str) ``path.to.plugin.task_fun`` to import or ``nf://path/to/task.py``\n        to download custom task\n    :param kwargs: (dict) arguments to use with specified task plugin\n    \"\"\"\n    # extract attributes\n    add_details = kwargs.pop(\"add_details\", False)  # ResultSerializer\n    to_dict = kwargs.pop(\"to_dict\", True)  # ResultSerializer\n    filters = {k: kwargs.pop(k) for k in list(kwargs.keys()) if k in FFun_functions}\n\n    # download task from broker and load it\n    if plugin.startswith(\"nf://\"):\n        function_text = self.fetch_file(plugin)\n        if function_text is None:\n            msg = f\"{self.name} - '{plugin}' task plugin download failed\"\n            log.error(msg)\n            return msg\n        # load task function running exec\n        globals_dict = {}\n        exec(function_text, globals_dict, globals_dict)\n        task_function = globals_dict[\"task\"]\n    # import task function\n    else:\n        # below same as \"from nornir.plugins.tasks import task_fun as task_function\"\n        task_fun = plugin.split(\".\")[-1]\n        try:\n            module = __import__(plugin, fromlist=[\"\"])\n            task_function = getattr(module, task_fun)\n        except Exception as e:\n            msg = f\"{self.name} - '{plugin}' task import failed with error '{e}'\"\n            log.error(msg)\n            return msg\n\n    self.nr.data.reset_failed_hosts()  # reset failed hosts\n    filtered_nornir = FFun(self.nr, **filters)  # filter hosts\n\n    # check if no hosts matched\n    if not filtered_nornir.inventory.hosts:\n        log.debug(\n            f\"{self.name} - nothing to do, no hosts matched by filters '{filters}'\"\n        )\n        return {} if to_dict else []\n\n    nr = self._add_processors(filtered_nornir, kwargs)  # add processors\n\n    # run task\n    log.debug(f\"{self.name} - running Nornir task '{plugin}', kwargs '{kwargs}'\")\n    result = nr.run(task=task_function, **kwargs)\n\n    return ResultSerializer(result, to_dict=to_dict, add_details=add_details)\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.cli","title":"<code>cli(commands=None, plugin='netmiko', cli_dry_run=False, run_ttp=None, **kwargs)</code>","text":"<p>Function to collect show commands output from devices using Command Line Interface (CLI)</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list</code> <p>list of commands to send to devices</p> <code>None</code> <code>plugin</code> <code>str</code> <p>plugin name to use - <code>netmiko</code>, <code>scrapli</code>, <code>napalm</code></p> <code>'netmiko'</code> <code>cli_dry_run</code> <code>bool</code> <p>do not send commands to devices just return them</p> <code>False</code> <code>run_ttp</code> <code>str</code> <p>TTP Template to run</p> <code>None</code> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def cli(\n    self,\n    commands: list = None,\n    plugin: str = \"netmiko\",\n    cli_dry_run: bool = False,\n    run_ttp: str = None,\n    **kwargs,\n) -&gt; dict:\n    \"\"\"\n    Function to collect show commands output from devices using\n    Command Line Interface (CLI)\n\n    :param commands: list of commands to send to devices\n    :param plugin: plugin name to use - ``netmiko``, ``scrapli``, ``napalm``\n    :param cli_dry_run: do not send commands to devices just return them\n    :param run_ttp: TTP Template to run\n    \"\"\"\n    ret = []\n    downloaded_cmds = []\n\n    # extract attributes\n    add_details = kwargs.pop(\"add_details\", False)  # ResultSerializer\n    to_dict = kwargs.pop(\"to_dict\", True)  # ResultSerializer\n    filters = {k: kwargs.pop(k) for k in list(kwargs.keys()) if k in FFun_functions}\n\n    # decide on what send commands task plugin to use\n    if plugin == \"netmiko\":\n        task_plugin = netmiko_send_commands\n    elif plugin == \"scrapli\":\n        task_plugin = scrapli_send_commands\n    elif plugin == \"napalm\":\n        task_plugin = napalm_send_commands\n    else:\n        raise UnsupportedPluginError(f\"Plugin '{plugin}' not supported\")\n\n    self.nr.data.reset_failed_hosts()  # reset failed hosts\n    filtered_nornir = FFun(self.nr, **filters)  # filter hosts\n\n    # check if no hosts matched\n    if not filtered_nornir.inventory.hosts:\n        log.debug(\n            f\"{self.name} - nothing to do, no hosts matched by filters '{filters}'\"\n        )\n        return {} if to_dict else []\n\n    # download TTP template if needed\n    if run_ttp and run_ttp.startswith(\"nf://\"):\n        downloaded = self.fetch_file(run_ttp)\n        kwargs[\"run_ttp\"] = downloaded\n        if downloaded is None:\n            log.error(f\"{self.name} - TTP template download failed '{run_ttp}'\")\n            return {} if to_dict else []\n\n    nr = self._add_processors(filtered_nornir, kwargs)  # add processors\n\n    # put a per-host list of commands to run\n    if commands:\n        commands = commands if isinstance(commands, list) else [commands]\n\n        # download commands from broker if needed\n        for command in commands:\n            if command.startswith(\"nf://\"):\n                downloaded = self.fetch_file(command)\n                if downloaded is not None:\n                    downloaded_cmds.append(downloaded)\n                else:\n                    log.error(f\"{self.name} - command download failed '{command}'\")\n            else:\n                downloaded_cmds.append(command)\n\n        # render commands using Jinja2 on a per-host basis\n        for host_name, host_object in nr.inventory.hosts.items():\n            context = {\"host\": host_object, \"norfab\": self.client, \"nornir\": self}\n            rendered_commands = []\n            for command in downloaded_cmds:\n                renderer = Environment(loader=\"BaseLoader\").from_string(command)\n                rendered_command = renderer.render(**context)\n                rendered_commands.append(rendered_command)\n            host_object.data[\"__task__\"] = {\"commands\": rendered_commands}\n\n    # run task\n    log.debug(\n        f\"{self.name} - running cli commands '{commands}', kwargs '{kwargs}', is cli dry run - '{cli_dry_run}'\"\n    )\n    if cli_dry_run is True:\n        result = nr.run(\n            task=nr_test, use_task_data=\"commands\", name=\"cli_dry_run\", **kwargs\n        )\n    else:\n        result = nr.run(task=task_plugin, **kwargs)\n\n    ret = ResultSerializer(result, to_dict=to_dict, add_details=add_details)\n\n    # remove __task__ data\n    for host_name, host_object in nr.inventory.hosts.items():\n        _ = host_object.data.pop(\"__task__\", None)\n\n    return ret\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.cfg","title":"<code>cfg(config, plugin='netmiko', cfg_dry_run=False, **kwargs)</code>","text":"<p>Function to send configuration commands to devices using Command Line Interface (CLI)</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>list</code> <p>list of commands to send to devices</p> required <code>plugin</code> <code>str</code> <p>plugin name to use - <code>netmiko</code>, <code>scrapli</code>, <code>napalm</code></p> <code>'netmiko'</code> <code>cfg_dry_run</code> <code>bool</code> <p>do not send commands to devices just return them</p> <code>False</code> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def cfg(\n    self, config: list, plugin: str = \"netmiko\", cfg_dry_run: bool = False, **kwargs\n) -&gt; dict:\n    \"\"\"\n    Function to send configuration commands to devices using\n    Command Line Interface (CLI)\n\n    :param config: list of commands to send to devices\n    :param plugin: plugin name to use - ``netmiko``, ``scrapli``, ``napalm``\n    :param cfg_dry_run: do not send commands to devices just return them\n    \"\"\"\n    ret = []\n    downloaded_cfg = []\n    config = config if isinstance(config, list) else [config]\n\n    # extract attributes\n    add_details = kwargs.pop(\"add_details\", False)  # ResultSerializer\n    to_dict = kwargs.pop(\"to_dict\", True)  # ResultSerializer\n    filters = {k: kwargs.pop(k) for k in list(kwargs.keys()) if k in FFun_functions}\n\n    # decide on what send commands task plugin to use\n    if plugin == \"netmiko\":\n        task_plugin = netmiko_send_config\n    elif plugin == \"scrapli\":\n        task_plugin = scrapli_send_config\n    elif plugin == \"napalm\":\n        task_plugin = napalm_configure\n    else:\n        raise UnsupportedPluginError(f\"Plugin '{plugin}' not supported\")\n\n    self.nr.data.reset_failed_hosts()  # reset failed hosts\n    filtered_nornir = FFun(self.nr, **filters)  # filter hosts\n\n    # check if no hosts matched\n    if not filtered_nornir.inventory.hosts:\n        log.debug(\n            f\"{self.name} - nothing to do, no hosts matched by filters '{filters}'\"\n        )\n        return {} if to_dict else []\n\n    nr = self._add_processors(filtered_nornir, kwargs)  # add processors\n\n    # download config from broker if needed\n    for command in config:\n        if command.startswith(\"nf://\"):\n            downloaded = self.fetch_file(command)\n            if downloaded is not None:\n                downloaded_cfg.append(downloaded)\n            else:\n                log.error(\n                    f\"{self.name} - config command download failed '{command}'\"\n                )\n        else:\n            downloaded_cfg.append(command)\n\n    # render config using Jinja2 on a per-host basis\n    for host_name, host_object in nr.inventory.hosts.items():\n        context = {\"host\": host_object}\n        host_object.data[\"__task__\"] = {\"config\": []}\n        for command in downloaded_cfg:\n            renderer = Environment(loader=\"BaseLoader\").from_string(command)\n            host_object.data[\"__task__\"][\"config\"].append(\n                renderer.render(**context)\n            )\n\n    # run task\n    log.debug(\n        f\"{self.name} - sending config commands '{config}', kwargs '{kwargs}', is cfg_dry_run - '{cfg_dry_run}'\"\n    )\n    if cfg_dry_run is True:\n        result = nr.run(\n            task=nr_test, use_task_data=\"config\", name=\"cfg_dry_run\", **kwargs\n        )\n    else:\n        result = nr.run(task=task_plugin, **kwargs)\n\n    ret = ResultSerializer(result, to_dict=to_dict, add_details=add_details)\n\n    # remove __task__ data\n    for host_name, host_object in nr.inventory.hosts.items():\n        _ = host_object.data.pop(\"__task__\", None)\n\n    return ret\n</code></pre>"},{"location":"nornir_worker_api_reference/#norfab.workers.nornir_worker.NornirWorker.test","title":"<code>test(suite, subset=None, dry_run=False, remove_tasks=True, failed_only=False, **kwargs)</code>","text":"<p>Function to tests data obtained from devices.</p> <p>Parameters:</p> Name Type Description Default <code>suite</code> <code>Union[list, str]</code> <p>path to YAML file with tests</p> required <code>dry_run</code> <code>bool</code> <p>if True, returns produced per-host tests suite content only</p> <code>False</code> <code>subset</code> <code>str</code> <p>list or string with comma separated non case sensitive glob patterns to filter tests' by name, subset argument ignored by dry run</p> <code>None</code> <code>failed_only</code> <code>bool</code> <p>if True returns test results for failed tests only</p> <code>False</code> <code>remove_tasks</code> <code>bool</code> <p>if False results will include other tasks output</p> <code>True</code> Source code in <code>norfab\\workers\\nornir_worker.py</code> <pre><code>def test(\n    self,\n    suite: Union[list, str],\n    subset: str = None,\n    dry_run: bool = False,\n    remove_tasks: bool = True,\n    failed_only: bool = False,\n    **kwargs,\n) -&gt; dict:\n    \"\"\"\n    Function to tests data obtained from devices.\n\n    :param suite: path to YAML file with tests\n    :param dry_run: if True, returns produced per-host tests suite content only\n    :param subset: list or string with comma separated non case sensitive glob\n        patterns to filter tests' by name, subset argument ignored by dry run\n    :param failed_only: if True returns test results for failed tests only\n    :param remove_tasks: if False results will include other tasks output\n    \"\"\"\n    ret = []\n    downloaded_suite = None\n    tests = {}  # dictionary to hold per-host test suites\n\n    # extract attributes\n    add_details = kwargs.pop(\"add_details\", False)  # ResultSerializer\n    to_dict = kwargs.pop(\"to_dict\", True)  # ResultSerializer\n    filters = {k: kwargs.pop(k) for k in list(kwargs.keys()) if k in FFun_functions}\n\n    self.nr.data.reset_failed_hosts()  # reset failed hosts\n    filtered_nornir = FFun(self.nr, **filters)  # filter hosts\n\n    # check if no hosts matched\n    if not filtered_nornir.inventory.hosts:\n        log.debug(\n            f\"{self.name} - nothing to do, no hosts matched by filters '{filters}'\"\n        )\n        return {} if to_dict else []\n\n    # download tests suite\n    downloaded_suite = self.fetch_file(suite)\n    if downloaded_suite is None:\n        msg = f\"{self.name} - '{suite}' suite download failed\"\n        log.error(msg)\n        return msg\n\n    # generate per-host test suites\n    for host_name, host_object in filtered_nornir.inventory.hosts.items():\n        context = {\"host\": host_object}\n        # render suite using Jinja2\n        try:\n            renderer = Environment(loader=\"BaseLoader\").from_string(\n                downloaded_suite\n            )\n            rendered_suite = renderer.render(**context)\n        except Exception as e:\n            msg = (\n                f\"{self.name} - '{suite}' Jinja2 rendering failed with error '{e}'\"\n            )\n            log.error(msg)\n            return msg\n        # load suit using YAML\n        try:\n            tests[host_name] = yaml.safe_load(rendered_suite)\n        except Exception as e:\n            msg = f\"{self.name} - '{suite}' YAML load failed with error '{e}'\"\n            log.error(msg)\n            return msg\n\n    # validate tests suite\n    try:\n        _ = modelTestsProcessorSuite(tests=tests)\n    except Exception as e:\n        msg = f\"{self.name} - '{suite}' suite validation failed with error '{e}'\"\n        log.error(msg)\n        return msg\n\n    # run task\n    log.debug(f\"{self.name} - running test '{suite}', is dry run - '{dry_run}'\")\n    if dry_run is True:\n        result = filtered_nornir.run(\n            task=nr_test, name=\"tests_dry_run\", ret_data_per_host=tests\n        )\n    else:\n        # add tests processor\n        nr = self._add_processors(\n            filtered_nornir,\n            kwargs={\n                \"tests\": tests,\n                \"remove_tasks\": remove_tasks,\n                \"failed_only\": failed_only,\n                \"subset\": subset,\n            },\n        )\n        result = nr.run(task=netmiko_send_commands, **kwargs)\n\n    ret = ResultSerializer(result, to_dict=to_dict, add_details=add_details)\n\n    return ret\n</code></pre>"}]}